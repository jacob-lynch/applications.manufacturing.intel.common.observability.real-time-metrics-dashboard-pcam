<QueryConfig AutoExecuteQueryOnLoad="false" PreventSQLBeautification="false">
  <ChangeLog>Changed by AMR\mfg_dmdavies on 11/10/2016 2:08:59 PM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.60808.1615</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 11/10/2016 2:01:07 PM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.60808.1615</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 11/10/2016 2:00:55 PM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.60808.1615</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 8/18/2014 2:02:23 PM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.8.40806.2215</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 4/17/2014 4:28:17 PM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.7.40416.2205</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 4/17/2014 4:27:36 PM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.7.40416.2205</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 4/17/2014 2:56:21 PM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.7.40416.2205</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 3/12/2014 3:39:27 PM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.7.40310.2257</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 3/12/2014 3:37:45 PM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.7.40310.2257</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 3/12/2014 3:37:35 PM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.7.40310.2257</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 5/1/2013 4:46:52 PM from RF3PTS215.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.6.30430.2016</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 4/29/2013 3:33:34 PM from RF3PTS215.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.6.30427.2018</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 2/15/2013 5:28:29 PM from RF3PTS215.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.6.30214.1454</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 1/16/2013 12:15:45 PM from RF3PTS215.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.6.30114.1906</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 1/16/2013 12:09:22 PM from RF3PTS215.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.6.30114.1906</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 1/16/2013 12:06:48 PM from RF3PTS215.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.6.30114.1906</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 1/16/2013 12:04:17 PM from RF3PTS215.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.6.30114.1906</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 1/16/2013 12:02:16 PM from RF3PTS215.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.6.30114.1906</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 9/6/2011 2:31:16 PM from RF3PTS215.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.4.10902.2313</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 9/6/2011 1:26:10 PM from RF3PTS215.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.4.10902.2313</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 9/5/2011 4:24:04 PM from RF3PTS215.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.4.10902.2313</ChangeLog>
  <ChangeLog>Changed by GER\mfg_dkiernan on 7/2/2011 9:01:13 AM from RF3PTS215.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.4.10614.2211</ChangeLog>
  <ChangeLog>Changed by GER\dkiernan on 6/29/2011 10:05:26 AM from RF3PTS215.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.4.10614.2211</ChangeLog>
  <ChangeLog>Changed by GER\dkiernan on 6/29/2011 8:29:23 AM from RF3PTS215.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.4.10614.2211</ChangeLog>
  <ChangeLog>Changed by GER\dkiernan on 6/27/2011 10:35:49 AM from RF3PTS215.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.4.10614.2211</ChangeLog>
  <QueryAttributes>
    <PreserveTempFiles>true</PreserveTempFiles>
    <AlwaysReplaceDomainWithLocal>false</AlwaysReplaceDomainWithLocal>
  </QueryAttributes>
  <PostQuerySQL>select * from %{OUTPUT}</PostQuerySQL>
  <TableLayoutConfig>
    <BoundColumnList>StateModel,CoreStateModelVersion</BoundColumnList>
  </TableLayoutConfig>
  <TabOrder>C0</TabOrder>
  <MainPivotConfig Enable="true">
    <ColumnX FieldName="State Model Version" FieldType="Int32" SortMode="Default" SortOrder="Ascending" SummaryType="Average" SortBySummaryInfo="false" />
    <ColumnY FieldName="" FieldType="" SortMode="Default" SortOrder="Ascending" SummaryType="Count" SortBySummaryInfo="false" />
    <ColumnData FieldName="COUNT OF" FieldType="String" SortMode="Default" SortOrder="Ascending" SummaryType="Count" SortBySummaryInfo="false" />
    <RotateXAxisLabels>false</RotateXAxisLabels>
    <Name>Core State Model Versions</Name>
    <ChartTitle>Core State Model Versions</ChartTitle>
    <ChartExportSize>800x400</ChartExportSize>
    <ShowLegend>false</ShowLegend>
    <IsYAxisVisible>false</IsYAxisVisible>
    <CustomPalette />
    <TableData />
  </MainPivotConfig>
  <AutoPivotConfig OutputDateFormat="yyyy ww.w hh tt" />
  <MailConfig>
    <PostProcessingSQL Enable="false" />
    <EmailCondition Enable="false" Operator="&lt;" ThresholdRowCount="0">
      <SQLQuery />
      <RunScriptBeforeEmailing>false</RunScriptBeforeEmailing>
      <Script />
    </EmailCondition>
    <PostProcessingCondition Enable="false" Operator="&gt;" ThresholdRowCount="0">
      <SQLQuery />
      <RunScriptBeforeEmailing>false</RunScriptBeforeEmailing>
    </PostProcessingCondition>
    <CopyCondition Enable="false" Operator="&gt;" ThresholdRowCount="0">
      <SQLQuery />
      <RunScriptBeforeEmailing>false</RunScriptBeforeEmailing>
    </CopyCondition>
    <SMTPServer>smtp.intel.com</SMTPServer>
    <From>LogAnalyzer2@intel.com</From>
    <ReplyTo>@{DASHBOARD_OWNER_ALERT_DIST}</ReplyTo>
    <To />
    <Subject>[${DOMAIN}] MESLotStateModel - XEUS</Subject>
    <Body />
    <MailAttachments FileNamingFormat="${SETTINGS}" Excel="false" LAS="false" LAD="false" Exceptions="false" StatusLogs="false" PivotChart="true" ZipAttachments="false" DoNotSendAttachmentsWithEmail="false" IncludeQuerySettingsFileHeader="false" IncludeVariableDefinitionHeader="false" />
    <IncludeSQLQueryInBody>false</IncludeSQLQueryInBody>
    <TableInBody Enable="false">
      <SQL />
    </TableInBody>
    <CopyOutputToDirectory>true</CopyOutputToDirectory>
    <OutputDirectory>@{DASHBOARD_WEB_SPOOL}\PCAM\Output</OutputDirectory>
    <IncludeAutoPivotSummary>false</IncludeAutoPivotSummary>
    <IgnoreExceptions>false</IgnoreExceptions>
    <OnlyCopyOutputIfEmailConditionIsMet>false</OnlyCopyOutputIfEmailConditionIsMet>
  </MailConfig>
  <TableSchema><xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Results" msdata:UseCurrentLocale="true">
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="Results">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="LOT" type="xs:string" minOccurs="0" />
              <xs:element name="State_x0020_Model" type="xs:string" minOccurs="0" />
              <xs:element name="State_x0020_Model_x0020_Version" type="xs:int" minOccurs="0" />
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:complexType>
  </xs:element>
</xs:schema>
</TableSchema>
  <TableData />
  <LastRunAbsoluteDateFilter />
  <CustomQueryMethodScripts>using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using Intel.LogAnalyzer;
using Intel.LogAnalyzer.Common;
using Intel.LogAnalyzer.Configuration;
using Intel.LogAnalyzer.Utility;

namespace Intel.LogAnalyzer.BuiltInQueryMethods_Temp
{
    public class JoinQueryMethod : CustomQueryMethodBase
    {
        /// &lt;summary&gt;
        /// Test harness
        /// &lt;/summary&gt;
        [STAThread]
        private static void Main()
        {
            new JoinQueryMethod
            {
                InputFile1 = @"D:\Temp\Anirudh\Table1.csv",
                InputFile2 = @"D:\Temp\Anirudh\Table2.csv",
                JoinColumn = "Col2,col3",
                IgnoreDuplicate = true,
                IgnoreCase = true
            }.Test();
        }
        
        // Output type is QueryResult
        public override CustomQueryOutputType OutputType { get { return CustomQueryOutputType.QueryResult; } }

        public override string Description
        {
            get { return "Do an outer join for two tables based on a matching column"; }
        }

        [Description("Input CSV File #1 containing table data")]
        public string InputFile1 { get; set; }

        [Description("Input CSV File #2 containing table data")]
        public string InputFile2 { get; set; }

        [Description("Input CSV File #3 containing table data (optional)")]
        [DefaultValue("")]
        public string InputFile3 { get; set; }

        [Description("Input CSV File #4 containing table data (optional)")]
        [DefaultValue("")]
        public string InputFile4 { get; set; }

        [Description("Input CSV File #5 containing table data (optional)")]
        [DefaultValue("")]
        public string InputFile5 { get; set; }

        [Description("Input CSV File #6 containing table data (optional)")]
        [DefaultValue("")]
        public string InputFile6 { get; set; }

        [Description("Column name(s) on which to join the two tables (more than one column can be supplied by using comma as a separator)")]
        public string JoinColumn { get; set; }

        [Description("Flag to ignore duplicate items in the JoinColumn")]
        [DefaultValue(false)]
        public bool IgnoreDuplicate { get; set; }

        [Description("Flag to ignore case in the JoinColumn")]
        [DefaultValue(false)]
        public bool IgnoreCase { get; set; }

        [Description("Flag to only show non-matching orphan rows")]
        [DefaultValue(false)]
        public bool OnlyShowNonMatchingRows { get; set; }

        [Description("Flag to also include non-matching orphan rows (but with blank entries)")]
        [DefaultValue(false)]
        public bool IncludeNonMatchingRows { get; set; }

        [Description("Name of columns (comma-separated) that must be included in output even if the join does not materialize")]
        [DefaultValue("")]
        public string MustIncludeOutputColumns { get; set; }

        public override QueryResult GetQueryResult()
        {
            List&lt;string&gt; files = new List&lt;string&gt; { InputFile1, InputFile2, InputFile3, InputFile4, InputFile5, InputFile6 }
                .FindAll(item =&gt; item.Trim().Length &gt; 0);

            DataTable table = new DataTable();
            string file = files[0];

            for (int i = 1; i &lt; files.Count; i++)
            {
                if (i &gt; 1)
                {
                    file = table.SaveToTempCSVFile();
                }
                table = JoinCSV(file, files[i]);
                if (i &gt; 1)
                {
                    UtilityMethods.DeleteTempFile(file);
                }
            }

            return new QueryResult(string.Empty, table);
        }

        private DataTable JoinCSV(string file1, string file2)
        {
            List&lt;string&gt; joinedHeader = new List&lt;string&gt;();
            List&lt;List&lt;string&gt;&gt; outputLines = new List&lt;List&lt;string&gt;&gt;();
            Dictionary&lt;string, List&lt;string&gt;&gt; joinDictionary = new Dictionary&lt;string, List&lt;string&gt;&gt;();
            int numFieldsToAppend;
            string error;
            const string KEY_SEPARATOR = "||";

            if (!UtilityMethods.DoesFileExistAndHaveContent(file1, out error))
            {
                return new DataTable();
            }

            if (!UtilityMethods.DoesFileExistAndHaveContent(file2, out error))
            {
                numFieldsToAppend = 0;
            }
            else
            {
                using (CsvReader csv = new CsvReader(file2))
                {
                    int fieldCount = csv.FieldCount;
                    List&lt;string&gt; headers = new List&lt;string&gt;(csv.GetFieldHeaders());
                    List&lt;int&gt; keyIndices = GetColumnIndices(JoinColumn, headers, "second");

                    numFieldsToAppend = fieldCount - 1;
                    for (int i = 0; i &lt; fieldCount; i++)
                    {
                        if (!keyIndices.Contains(i))
                        {
                            joinedHeader.Add(headers[i]);
                        }
                    }

                    int count = 0;
                    while (csv.ReadNextRecord())
                    {
                        List&lt;string&gt; fields = new List&lt;string&gt;();

                        for (int i = 0; i &lt; fieldCount; i++)
                        {
                            if (!keyIndices.Contains(i))
                            {
                                fields.Add(csv[i]);
                            }
                        }

                        ++count;
                        string key = string.Empty;
                        foreach (int keyIndex in keyIndices)
                        {
                            if (key.Length &gt; 0) key += KEY_SEPARATOR;
                            key += IgnoreCase ? csv[keyIndex].ToLower() : csv[keyIndex];
                        }

                        if (joinDictionary.ContainsKey(key))
                        {
                            if (IgnoreDuplicate)
                            {
                                // do nothing....ignore this
                            }
                            else
                            {
                                string oldValue = joinDictionary[key].ConvertListToCSV();
                                string newValue = fields.ConvertListToCSV();

                                throw new DuplicateNameException("Duplicate key ["
                                    + key + "] found in row " + count + " of first CSV "
                                    + Environment.NewLine
                                    + Environment.NewLine + "Old value = " + oldValue
                                    + Environment.NewLine + "New value = " + newValue);
                            }
                        }
                        else
                        {
                            joinDictionary.Add(key, fields);
                        }
                    }
                }
            }

            using (CsvReader csv = new CsvReader(file1))
            {
                csv.SupportsMultiline = false;
                csv.ParseNonStandardQuotedField = true;

                int fieldCount = csv.FieldCount;
                List&lt;string&gt; headers = new List&lt;string&gt;(csv.GetFieldHeaders());
                List&lt;int&gt; keyIndices = GetColumnIndices(JoinColumn, headers, "first");

                if (!OnlyShowNonMatchingRows)
                {
                    joinedHeader.InsertRange(0, headers);
                }
                else
                {
                    joinedHeader.Clear();
                    joinedHeader.AddRange(headers);
                }

                while (csv.ReadNextRecord())
                {
                    string key = string.Empty;
                    foreach (int keyIndex in keyIndices)
                    {
                        if (key.Length &gt; 0) key += KEY_SEPARATOR;
                        key += IgnoreCase ? csv[keyIndex].ToLower() : csv[keyIndex];
                    }

                    if (!OnlyShowNonMatchingRows)
                    {
                        List&lt;string&gt; fields = new List&lt;string&gt;();
                        for (int i = 0; i &lt; fieldCount; i++)
                        {
                            fields.Add(csv[i]);
                        }

                        if (joinDictionary.ContainsKey(key))
                        {
                            fields.AddRange(joinDictionary[key]);
                            outputLines.Add(fields);
                        }
                        else if (IncludeNonMatchingRows)
                        {
                            for (int i = 0; i &lt; numFieldsToAppend; i++)
                            {
                                fields.Add(string.Empty);
                            }
                            outputLines.Add(fields);
                        }
                    }
                    else
                    {
                        if (!(joinDictionary.ContainsKey(key)))
                        {
                            List&lt;string&gt; fields = new List&lt;string&gt;();
                            for (int i = 0; i &lt; fieldCount; i++)
                            {
                                fields.Add(csv[i]);
                            }
                            outputLines.Add(fields);
                        }
                    }
                }
            }

            DataTable outTable = UtilityMethods.ConvertToDataTable(joinedHeader, outputLines);

            if (MustIncludeOutputColumns.Trim().Length &gt; 0) // add any must-have columns to output
            {
                List&lt;string&gt; colsToAdd = new List&lt;string&gt;(MustIncludeOutputColumns.Split(','))
                    .ConvertAll(item =&gt; item.Trim())
                    .FindAll(item =&gt; item.Length &gt; 0);
                foreach (string colToAdd in colsToAdd)
                {
                    if (outTable.GetColumnIndex(colToAdd) &lt; 0) // column does not exist
                    {
                        outTable.Columns.Add(colToAdd, typeof(string));
                    }
                }
            }

            return outTable;
        }

        private static List&lt;int&gt; GetColumnIndices(string columnList, List&lt;string&gt; headers, string csvFileToken)
        {
            List&lt;string&gt; columns = new List&lt;string&gt;(columnList.Split(',')).ConvertAll&lt;string&gt;(item =&gt; item.Trim()).FindAll(item =&gt; item.Length &gt; 0);
            List&lt;int&gt; colIndices = new List&lt;int&gt;();
            
            foreach (string column in columns)
            {
                string col = column;
                if (col.StartsWith("[") &amp;&amp; col.EndsWith("]"))
                {
                    col = col.Replace("[", string.Empty).Replace("]", string.Empty);
                }
                int index = headers.FindIndex(item =&gt; item.Equals(col, StringComparison.CurrentCultureIgnoreCase));
                if (index &lt; 0)
                {
                    throw new Exception("Key column [" + col + "] not found in the " + csvFileToken + " CSV file.");
                }
                colIndices.Add(index);
            }

            return colIndices;
        }
    }
}
</CustomQueryMethodScripts>
  <PivotGroupingSettings PivotColumn="">
    <SortyByColumn>Count</SortyByColumn>
  </PivotGroupingSettings>
  <QuerySQL><![CDATA[
--[FileName:"D:\Dashboard\Jobs\PCAM\24-hr\MES Lot State Model_XEUS.lasx"]------
----------<VARIABLES>------------
var MAO_USERID = "@{USERID_NON_MFG}"
var DATA_SOURCE = "@{LOCALXEUSDATASOURCE}"
var FA_EXCLUDE = "@{MES300_FA_EXCLUDE}"
---[MES300_CSV]---
BEGIN MES300_CSV
	---Begin Main Query---
	Using UNIQE with
		DataSource = "${DATA_SOURCE}" -- UNIQE data source to query
		Authentication = "UNP" -- User Authentication Mode
		UserId = "${MAO_USERID}" -- User ID for authentication
	SELECT
	  LOT,
	  STATE_MODEL,
	  STATE_MODEL_VERSION
	FROM
	  F_LOT
	WHERE
	  SRC_ERASE_DATE IS NULL
	  AND TERMINATED != 'Y' 
END MES300_CSV
---Begin Main Query---
Using CSV with
SELECT
	Lot,
	State_Model as [State Model],
	state_model_version as [State Model Version]
FROM
	%{MES300_CSV}
ORDER BY
	Lot

]]></QuerySQL>
</QueryConfig>