<QueryConfig AutoExecuteQueryOnLoad="false" PreventSQLBeautification="false">
  <ChangeLog>Changed by AMR\mfg_dmdavies on 11/8/2016 2:24:43 PM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.60808.1615</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 11/8/2016 2:23:20 PM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.60808.1615</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 11/8/2016 2:22:42 PM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.60808.1615</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 11/8/2016 2:10:24 PM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.60808.1615</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 11/8/2016 2:09:48 PM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.60808.1615</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 11/8/2016 2:08:54 PM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.60808.1615</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 11/8/2016 1:58:22 PM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.60808.1615</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 11/8/2016 1:55:08 PM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.60808.1615</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 11/14/2014 2:21:27 PM from RF3PAP216N3.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.8.40713.1943</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 11/14/2014 2:21:19 PM from RF3PAP216N3.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.8.40713.1943</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 11/14/2014 2:20:29 PM from RF3PAP216N3.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.8.40713.1943</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 11/10/2014 1:37:32 PM from RF3PAP216N3.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.8.40713.1943</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 8/27/2014 12:32:14 PM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.8.40806.2215</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 8/27/2014 12:05:06 PM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.8.40806.2215</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 8/27/2014 12:04:11 PM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.8.40806.2215</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 8/27/2014 12:03:37 PM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.8.40806.2215</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 8/27/2014 11:53:46 AM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.8.40806.2215</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 8/27/2014 11:28:22 AM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.8.40806.2215</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 8/27/2014 11:28:16 AM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.8.40806.2215</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 8/27/2014 11:27:07 AM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.8.40806.2215</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 8/27/2014 11:25:45 AM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.8.40806.2215</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 8/27/2014 11:24:40 AM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.8.40806.2215</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 8/27/2014 10:07:16 AM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.8.40806.2215</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 8/27/2014 8:33:27 AM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.8.40806.2215</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 8/27/2014 8:33:07 AM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.8.40806.2215</ChangeLog>
  <QueryAttributes>
    <RowThresholdForPivotGrid>1000000</RowThresholdForPivotGrid>
    <AlwaysReplaceDomainWithLocal>false</AlwaysReplaceDomainWithLocal>
  </QueryAttributes>
  <PostQuerySQL>select * from %{OUTPUT}</PostQuerySQL>
  <TableLayoutConfig>
    <BoundColumnList>DateTime,NodeName,EventLog,EventID,EventTypeName,Category,SourceName,UserID,Message,Strings</BoundColumnList>
  </TableLayoutConfig>
  <RowHighlightingRules Enable="true" ColumnName="*" FilterRegex="Error" RowColorString="NamedColor:Red" />
  <RowHighlightingRules Enable="true" ColumnName="*" FilterRegex="Warning" RowColorString="NamedColor:Yellow" />
  <TabOrder>C0,C1,C2,C3,C4,G0</TabOrder>
  <MainPivotConfig>
    <ColumnX FieldName="" FieldType="" SortMode="Default" SortOrder="Ascending" SummaryType="Count" SortBySummaryInfo="false" />
    <ColumnY FieldName="" FieldType="" SortMode="Default" SortOrder="Ascending" SummaryType="Count" SortBySummaryInfo="false" />
    <ColumnData FieldName="" FieldType="" SortMode="Default" SortOrder="Ascending" SummaryType="Count" SortBySummaryInfo="false" />
    <CustomPalette />
    <TableData />
  </MainPivotConfig>
  <MainPivotConfig Enable="true">
    <QuerySQL>---Begin Main Query---
SELECT
	*
FROM
	%{OUTPUT}
WHERE
	Comment like '%SAFE%'
</QuerySQL>
    <ColumnX FieldName="Process" FieldType="String" SortMode="Default" SortOrder="Ascending" SummaryType="Count" SortBySummaryInfo="false" />
    <ColumnY FieldName="LineSegment" FieldType="String" SortMode="Default" SortOrder="Ascending" SummaryType="Count" SortBySummaryInfo="false" />
    <ColumnData FieldName="COUNT OF" FieldType="String" SortMode="Default" SortOrder="Ascending" SummaryType="Count" SortBySummaryInfo="false" />
    <ChartType>StackedBar</ChartType>
    <RotateXAxisLabels>false</RotateXAxisLabels>
    <ShowColumnTotals>false</ShowColumnTotals>
    <Name>Safe Operations by Process</Name>
    <ChartTitle>Safe Operations by Process</ChartTitle>
    <ColorPalette>Median</ColorPalette>
    <ChartExportSize>800x400</ChartExportSize>
    <CustomPalette />
    <TableData />
  </MainPivotConfig>
  <MainPivotConfig Enable="true">
    <QuerySQL>----------&lt;VARIABLES&gt;------------
var DATA_SOURCE = "@{LOCALXEUSDATASOURCE}"
---[MAIN_CSV]---
BEGIN MAIN_CSV
	---Begin Main Query---
	SELECT
		DISTINCT
		Operation,
		PurgeOnLoadPort
	FROM
		%{OUTPUT}
	WHERE
		Enable = 'Y'
		AND PurgeOnLoadPort = 'Y'
END MAIN_CSV
---[OPER_CSV]---
BEGIN OPER_CSV
	---Begin Main Query---
	Using UNIQE with
		DataSource = "${DATA_SOURCE}" -- UNIQE data source to query
		Authentication = "UNP" -- User Authentication Mode
		UserId = "${MAO_USERID}" -- User ID for authentication
	SELECT
	  OPERATION,
	  CU_FLAG,
	  STATE,
	  DOTPROCESS
	FROM
	  F_OPERATION
	WHERE
	  LATEST_VERSION = 'Y'
	  AND SRC_ERASE_DATE IS NULL 
END OPER_CSV
---[JOIN_CSV]---
BEGIN JOIN_CSV
	UseMethod Join with -- **Do an outer join for two tables based on a matching column**
		InputFile1 = "%{OPER_CSV}" -- Input CSV File #1 containing table data [String]
		InputFile2 = "%{MAIN_CSV}" -- Input CSV File #2 containing table data [String]
		InputFile3 = "" -- Input CSV File #3 containing table data (optional) [String]
		InputFile4 = "" -- Input CSV File #4 containing table data (optional) [String]
		InputFile5 = "" -- Input CSV File #5 containing table data (optional) [String]
		InputFile6 = "" -- Input CSV File #6 containing table data (optional) [String]
		JoinColumn = "Operation" -- Column name(s) on which to join the two tables (more than one column can be supplied by using comma as a separator) [String]
		IgnoreDuplicate = false -- Flag to ignore duplicate items in the JoinColumn [Boolean]
		IgnoreCase = false -- Flag to ignore case in the JoinColumn [Boolean]
		OnlyShowNonMatchingRows = false -- Flag to only show non-matching orphan rows [Boolean]
		IncludeNonMatchingRows = true -- Flag to also include non-matching orphan rows (but with blank entries) [Boolean]
		MustIncludeOutputColumns = "" -- Name of columns (comma-separated) that must be included in output even if the join does not materialize [String]
		OrderBy = "" -- Name of column(s) to sort the resulting table by [String]
END JOIN_CSV
---Begin Main Query---
Using CSV with
SELECT
	Process,
	[Purge On Load Port],
	MUL(PROPCOUNT(*) ON (Process), 100.0) as Total
USING
	CASE index_of(DOTPROCESS, 'GEN') when null then DOTPROCESS else '300mm' end as ProcTmp,
	REPLACE_STR(ProcTmp, 'TW', '.0') as Process1,
	STRCAT(STRCAT(Process1, ' '), LineSegment) as Process,
	CASE CU_FLAG when 'Required' then 'BE' else 'FE' end as LineSegment,
	CASE PurgeOnLoadPort when Null then 'No' else 'Yes' end as [Purge On Load Port]
FROM
	%{JOIN_CSV}
WHERE
	State like 'Active'
	AND NOT IsInList(Process, '${PURGE_EXCLUDE_PROCESS}')
GROUP BY
	Process, [Purge On Load Port]
ORDER BY
	Process, [Purge On Load Port]
</QuerySQL>
    <ColumnX FieldName="Process" FieldType="String" SortMode="Default" SortOrder="Ascending" SummaryType="Count" SortBySummaryInfo="false" />
    <ColumnY FieldName="Purge On Load Port" FieldType="String" SortMode="Default" SortOrder="Ascending" SummaryType="Count" SortBySummaryInfo="false" />
    <ColumnData FieldName="Total" FieldType="Double" SortMode="Default" SortOrder="Ascending" SummaryType="Average" SortBySummaryInfo="false" />
    <ChartType>StackedBar</ChartType>
    <RotateXAxisLabels>false</RotateXAxisLabels>
    <ShowColumnTotals>false</ShowColumnTotals>
    <Name>Operations with PurgeOnLoadPort Enabled by Process</Name>
    <ChartTitle>Percentage of Active Operations with PurgeOnLoadPort</ChartTitle>
    <ColorPalette>Median</ColorPalette>
    <ChartExportSize>800x400</ChartExportSize>
    <IsYAxisVisible>false</IsYAxisVisible>
    <CustomPalette />
    <TableData />
  </MainPivotConfig>
  <MainPivotConfig Enable="true">
    <QuerySQL>----------&lt;VARIABLES&gt;------------
var DATA_SOURCE = "@{LOCALXEUSDATASOURCE}"
---[MAIN_CSV]---
BEGIN MAIN_CSV
	---Begin Main Query---
	SELECT
		DISTINCT
		Operation,
		PurgeInStocker
	FROM
		%{OUTPUT}
	WHERE
		Enable = 'Y'
		AND PurgeInStocker = 'Y'
END MAIN_CSV
---[OPER_CSV]---
BEGIN OPER_CSV
	---Begin Main Query---
	Using UNIQE with
		DataSource = "${DATA_SOURCE}" -- UNIQE data source to query
		Authentication = "UNP" -- User Authentication Mode
		UserId = "${MAO_USERID}" -- User ID for authentication
	SELECT
	  OPERATION,
	  CU_FLAG,
	  STATE,
	  DOTPROCESS
	FROM
	  F_OPERATION
	WHERE
	  LATEST_VERSION = 'Y'
	  AND SRC_ERASE_DATE IS NULL 
END OPER_CSV
---[JOIN_CSV]---
BEGIN JOIN_CSV
	UseMethod Join with -- **Do an outer join for two tables based on a matching column**
		InputFile1 = "%{OPER_CSV}" -- Input CSV File #1 containing table data [String]
		InputFile2 = "%{MAIN_CSV}" -- Input CSV File #2 containing table data [String]
		InputFile3 = "" -- Input CSV File #3 containing table data (optional) [String]
		InputFile4 = "" -- Input CSV File #4 containing table data (optional) [String]
		InputFile5 = "" -- Input CSV File #5 containing table data (optional) [String]
		InputFile6 = "" -- Input CSV File #6 containing table data (optional) [String]
		JoinColumn = "Operation" -- Column name(s) on which to join the two tables (more than one column can be supplied by using comma as a separator) [String]
		IgnoreDuplicate = false -- Flag to ignore duplicate items in the JoinColumn [Boolean]
		IgnoreCase = false -- Flag to ignore case in the JoinColumn [Boolean]
		OnlyShowNonMatchingRows = false -- Flag to only show non-matching orphan rows [Boolean]
		IncludeNonMatchingRows = true -- Flag to also include non-matching orphan rows (but with blank entries) [Boolean]
		MustIncludeOutputColumns = "" -- Name of columns (comma-separated) that must be included in output even if the join does not materialize [String]
		OrderBy = "" -- Name of column(s) to sort the resulting table by [String]
END JOIN_CSV
---Begin Main Query---
Using CSV with
SELECT
	Process,
	[Purge In Stocker],
	MUL(PROPCOUNT(*) ON (Process), 100.0) as Total
USING
	CASE index_of(DOTPROCESS, 'GEN') when null then DOTPROCESS else '300mm' end as ProcTmp,
	REPLACE_STR(ProcTmp, 'TW', '.0') as Process1,
	STRCAT(STRCAT(Process1, ' '), LineSegment) as Process,
	CASE CU_FLAG when 'Required' then 'BE' else 'FE' end as LineSegment,
	CASE PurgeInStocker when Null then 'No' else 'Yes' end as [Purge In Stocker]
FROM
	%{JOIN_CSV}
WHERE
	State like 'Active'
	AND NOT IsInList(Process, '${PURGE_EXCLUDE_PROCESS}')
GROUP BY
	Process, [Purge In Stocker]
ORDER BY
	Process, [Purge In Stocker]
</QuerySQL>
    <ColumnX FieldName="Process" FieldType="String" SortMode="Default" SortOrder="Ascending" SummaryType="Count" SortBySummaryInfo="false" />
    <ColumnY FieldName="Purge In Stocker" FieldType="String" SortMode="Default" SortOrder="Ascending" SummaryType="Count" SortBySummaryInfo="false" />
    <ColumnData FieldName="Total" FieldType="Double" SortMode="Default" SortOrder="Ascending" SummaryType="Average" SortBySummaryInfo="false" />
    <ChartType>StackedBar</ChartType>
    <RotateXAxisLabels>false</RotateXAxisLabels>
    <ShowColumnTotals>false</ShowColumnTotals>
    <Name>Operations with PurgeInStocker Enabled by Process</Name>
    <ChartTitle>Percentage of Active Operations with PurgeInStocker</ChartTitle>
    <ColorPalette>Median</ColorPalette>
    <ChartExportSize>800x400</ChartExportSize>
    <ShowThresholdLineCaption>false</ShowThresholdLineCaption>
    <IsYAxisVisible>false</IsYAxisVisible>
    <CustomPalette />
    <TableData />
  </MainPivotConfig>
  <MainPivotConfig Enable="true">
    <QuerySQL>----------&lt;VARIABLES&gt;------------
var MAO_USERID = "@{USERID_NON_MFG}"
var DATA_SOURCE = "@{LOCALXEUSDATASOURCE}"
---[MAIN_CSV]---
BEGIN MAIN_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		[Associated Entities with Purge Enabled] as Enabled,
		[Associated Entities with Purge Disabled or Status Unknown] as Disabled
	FROM
		%{OUTPUT}
END MAIN_CSV
---[TRANS_CSV]---
BEGIN TRANS_CSV
	UseMethod TransformColumnToRow with -- **Transforms selected table columns into rows**
		InputFiles = "%{MAIN_CSV}" -- Input files (comma-separated) containing table data [String]
		ColumnsToConvert = "Enabled,Disabled" -- Name of columns to convert into rows (comma-separated) [String]
		ColumnsToExclude = "" -- Name of columns to exclude from conversion (comma-separated) [String]
		ColumnNameForCaption = "Purge" -- Caption for new column type created after transformation [String]
		ColumnNameForValue = "Entity" -- Caption for new column value created after transformation [String]
END TRANS_CSV
---[SPLIT_CSV]---
BEGIN SPLIT_CSV
	UseMethod SplitRow with -- **Splits a row into one or more rows with two columns each**
		InputFiles = "%{TRANS_CSV}" -- Input files (comma-separated) containing table data [String]
		ColumnToSplit = "Entity" -- Name of column to split into multiple rows [String]
		Separator = "," -- Separator string to use when splitting rows [String]
		TrimValue = true -- Trim the value of column after splitting [Boolean]
		RemoveEmptyEntries = false -- Remove empty entries found after splitting [Boolean]
END SPLIT_CSV
---[FA_CSV]---
BEGIN FA_CSV
	---Begin Main Query---
	Using UNIQE with
		DataSource = "${DATA_SOURCE}" -- UNIQE data source to query
		Authentication = "UNP" -- User Authentication Mode
		UserId = "${MAO_USERID}" -- User ID for authentication
	SELECT
	  m.ENTITY          AS Entity,
	  m.FUNCTIONAL_AREA AS AREA
	FROM
	  F_ENTITY m
	WHERE
	  m.ENTITY_DELETED_FLAG != 'Y'
	  AND m.OBJECT_STATUS = '1'
	  AND m.GENERAL_TYPE = 'Equipment'
	ORDER  BY
	  m.Entity 
END FA_CSV
---[JOIN_CSV]---
BEGIN JOIN_CSV
	UseMethod Join with -- **Do an outer join for two tables based on a matching column**
		InputFile1 = "%{SPLIT_CSV}" -- Input CSV File #1 containing table data [String]
		InputFile2 = "%{FA_CSV}" -- Input CSV File #2 containing table data [String]
		InputFile3 = "" -- Input CSV File #3 containing table data (optional) [String]
		InputFile4 = "" -- Input CSV File #4 containing table data (optional) [String]
		InputFile5 = "" -- Input CSV File #5 containing table data (optional) [String]
		InputFile6 = "" -- Input CSV File #6 containing table data (optional) [String]
		JoinColumn = "Entity" -- Column name(s) on which to join the two tables (more than one column can be supplied by using comma as a separator) [String]
		IgnoreDuplicate = true -- Flag to ignore duplicate items in the JoinColumn [Boolean]
		IgnoreCase = false -- Flag to ignore case in the JoinColumn [Boolean]
		OnlyShowNonMatchingRows = false -- Flag to only show non-matching orphan rows [Boolean]
		IncludeNonMatchingRows = true -- Flag to also include non-matching orphan rows (but with blank entries) [Boolean]
		MustIncludeOutputColumns = "" -- Name of columns (comma-separated) that must be included in output even if the join does not materialize [String]
		OrderBy = "" -- Name of column(s) to sort the resulting table by [String]
END JOIN_CSV
---Begin Main Query---
Using CSV with
SELECT
	distinct
	FunctionalArea,
	Purge,
	MUL(PROPCOUNT(*) ON (FunctionalArea), 100.0) as Total
USING
	Case AREA when 'FabSupportGroup' then 'FSG' when 'RP1Analytical' then 'RP1' when 'RP1Lithography' then 'RP1' when 'RP1ThinFilms' then 'RP1' when 'Etch' then 'Dry Etch' when 'WetEtch' then 'Wet Etch'  when 'Metrology' then 'Defect Metro' when 'Analytical' then 'EquipMetro' else AREA end as FunctionalArea
FROM
	%{JOIN_CSV}
WHERE
	Entity is not null
	AND FunctionalArea is not null
GROUP BY
	FunctionalArea, Purge
ORDER BY
	FunctionalArea, Purge
</QuerySQL>
    <ColumnX FieldName="Purge" FieldType="String" SortMode="Default" SortOrder="Ascending" SummaryType="Count" SortBySummaryInfo="false" />
    <ColumnY FieldName="FunctionalArea" FieldType="String" SortMode="Default" SortOrder="Ascending" SummaryType="Count" SortBySummaryInfo="false" />
    <ColumnData FieldName="Total" FieldType="Double" SortMode="Default" SortOrder="Ascending" SummaryType="Average" SortBySummaryInfo="false" />
    <DisplayChartBorder>false</DisplayChartBorder>
    <ChartType>Pie</ChartType>
    <ShowLabels>false</ShowLabels>
    <ShowColumnTotals>false</ShowColumnTotals>
    <Name>Tools</Name>
    <ChartTitle>Tools with Purge Enabled by Area</ChartTitle>
    <ColorPalette>Median</ColorPalette>
    <ShowThresholdLineCaption>false</ShowThresholdLineCaption>
    <CustomPalette />
    <TableData />
  </MainPivotConfig>
  <OutputDataGridConfig Name="Purge_Tools" IncludeInBody="false" IncludeInAttachment="true">
    <SQL>----------&lt;VARIABLES&gt;------------
var MAO_USERID = "@{USERID_NON_MFG}"
var DATA_SOURCE = "@{LOCALXEUSDATASOURCE}"
---[MAIN_CSV]---
BEGIN MAIN_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		[Associated Entities with Purge Enabled] as Enabled,
		[Associated Entities with Purge Disabled or Status Unknown] as Disabled
	FROM
		%{OUTPUT}
END MAIN_CSV
---[TRANS_CSV]---
BEGIN TRANS_CSV
	UseMethod TransformColumnToRow with -- **Transforms selected table columns into rows**
		InputFiles = "%{MAIN_CSV}" -- Input files (comma-separated) containing table data [String]
		ColumnsToConvert = "Enabled,Disabled" -- Name of columns to convert into rows (comma-separated) [String]
		ColumnsToExclude = "" -- Name of columns to exclude from conversion (comma-separated) [String]
		ColumnNameForCaption = "Purge" -- Caption for new column type created after transformation [String]
		ColumnNameForValue = "Entity" -- Caption for new column value created after transformation [String]
END TRANS_CSV
---[SPLIT_CSV]---
BEGIN SPLIT_CSV
	UseMethod SplitRow with -- **Splits a row into one or more rows with two columns each**
		InputFiles = "%{TRANS_CSV}" -- Input files (comma-separated) containing table data [String]
		ColumnToSplit = "Entity" -- Name of column to split into multiple rows [String]
		Separator = "," -- Separator string to use when splitting rows [String]
		TrimValue = true -- Trim the value of column after splitting [Boolean]
		RemoveEmptyEntries = false -- Remove empty entries found after splitting [Boolean]
END SPLIT_CSV
---[FA_CSV]---
BEGIN FA_CSV
	---Begin Main Query---
	Using UNIQE with
		DataSource = "${DATA_SOURCE}" -- UNIQE data source to query
		Authentication = "UNP" -- User Authentication Mode
		UserId = "${MAO_USERID}" -- User ID for authentication
	SELECT
	  m.ENTITY          AS Entity,
	  m.FUNCTIONAL_AREA AS AREA
	FROM
	  F_ENTITY m
	WHERE
	  m.ENTITY_DELETED_FLAG != 'Y'
	  AND m.OBJECT_STATUS = '1'
	  AND m.GENERAL_TYPE = 'Equipment'
	ORDER  BY
	  m.Entity 
END FA_CSV
---[JOIN_CSV]---
BEGIN JOIN_CSV
	UseMethod Join with -- **Do an outer join for two tables based on a matching column**
		InputFile1 = "%{SPLIT_CSV}" -- Input CSV File #1 containing table data [String]
		InputFile2 = "%{FA_CSV}" -- Input CSV File #2 containing table data [String]
		InputFile3 = "" -- Input CSV File #3 containing table data (optional) [String]
		InputFile4 = "" -- Input CSV File #4 containing table data (optional) [String]
		InputFile5 = "" -- Input CSV File #5 containing table data (optional) [String]
		InputFile6 = "" -- Input CSV File #6 containing table data (optional) [String]
		JoinColumn = "Entity" -- Column name(s) on which to join the two tables (more than one column can be supplied by using comma as a separator) [String]
		IgnoreDuplicate = true -- Flag to ignore duplicate items in the JoinColumn [Boolean]
		IgnoreCase = false -- Flag to ignore case in the JoinColumn [Boolean]
		OnlyShowNonMatchingRows = false -- Flag to only show non-matching orphan rows [Boolean]
		IncludeNonMatchingRows = true -- Flag to also include non-matching orphan rows (but with blank entries) [Boolean]
		MustIncludeOutputColumns = "" -- Name of columns (comma-separated) that must be included in output even if the join does not materialize [String]
		OrderBy = "" -- Name of column(s) to sort the resulting table by [String]
END JOIN_CSV
---Begin Main Query---
Using CSV with
SELECT
	distinct
	FunctionalArea,
	Entity,
	Purge as [Purge Enabled]
USING
	Case AREA when 'FabSupportGroup' then 'FSG' when 'RP1Analytical' then 'RP1' when 'Etch' then 'Dry Etch' when 'WetEtch' then 'Wet Etch'  when 'Metrology' then 'Defect Metro' when 'Analytical' then 'EquipMetro' else AREA end as FunctionalArea
FROM
	%{JOIN_CSV}
WHERE
	Entity is not null
	AND FunctionalArea is not null
ORDER BY
	FunctionalArea,
	Entity
</SQL>
    <TableLayoutConfig>
      <BoundColumnList>NewColumn,Value</BoundColumnList>
    </TableLayoutConfig>
    <TableSchema><xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Results" msdata:UseCurrentLocale="true">
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="Results">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="FunctionalArea" type="xs:string" minOccurs="0" />
              <xs:element name="Entity" type="xs:string" minOccurs="0" />
              <xs:element name="Purge_x0020_Enabled" type="xs:string" minOccurs="0" />
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:complexType>
  </xs:element>
</xs:schema>
</TableSchema>
    <TableData />
  </OutputDataGridConfig>
  <AutoPivotConfig OutputDateFormat="yyyy ww.w HH:mm" StatisticalFunctionsForColumn="Avg, 50, 90,96, Count" />
  <MailConfig>
    <PostProcessingSQL Enable="false" />
    <EmailCondition Enable="false" Operator="&gt;=" ThresholdRowCount="0">
      <SQLQuery />
      <RunScriptBeforeEmailing>false</RunScriptBeforeEmailing>
      <Script />
    </EmailCondition>
    <PostProcessingCondition Enable="false" Operator="&gt;" ThresholdRowCount="0">
      <SQLQuery />
      <RunScriptBeforeEmailing>false</RunScriptBeforeEmailing>
    </PostProcessingCondition>
    <CopyCondition Enable="false" Operator="&gt;" ThresholdRowCount="">
      <SQLQuery />
      <RunScriptBeforeEmailing>false</RunScriptBeforeEmailing>
    </CopyCondition>
    <SMTPServer>smtp.intel.com</SMTPServer>
    <From>LogAnalyzer2@intel.com</From>
    <ReplyTo>@{DASHBOARD_OWNER_ALERT_DIST}</ReplyTo>
    <To />
    <Subject>Purge Metrics XEUS</Subject>
    <Body />
    <MailAttachments FileNamingFormat="${SETTINGS}" Excel="false" LAS="false" LAD="false" Exceptions="false" StatusLogs="false" PivotChart="true" ZipAttachments="false" DoNotSendAttachmentsWithEmail="false" IncludeJobStatisticsHeader="false" IncludeQuerySettingsFileHeader="false" IncludeVariableDefinitionHeader="false" IncludeRowCountInSubject="false" />
    <IncludeSQLQueryInBody>false</IncludeSQLQueryInBody>
    <TableInBody Enable="false">
      <SQL />
    </TableInBody>
    <CopyOutputToDirectory>true</CopyOutputToDirectory>
    <OutputDirectory>@{DASHBOARD_WEB_SPOOL}\PCAM\Output</OutputDirectory>
    <IncludeAutoPivotSummary>false</IncludeAutoPivotSummary>
    <IgnoreExceptions>false</IgnoreExceptions>
    <OnlyCopyOutputIfEmailConditionIsMet>false</OnlyCopyOutputIfEmailConditionIsMet>
  </MailConfig>
  <TableSchema><xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Results" msdata:UseCurrentLocale="true">
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="Results">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="Enable" type="xs:string" minOccurs="0" />
              <xs:element name="State" type="xs:string" minOccurs="0" />
              <xs:element name="Operation" type="xs:int" minOccurs="0" />
              <xs:element name="Process" type="xs:string" minOccurs="0" />
              <xs:element name="LineSegment" type="xs:string" minOccurs="0" />
              <xs:element name="Route" type="xs:string" minOccurs="0" />
              <xs:element name="PurgeOnLoadPort" type="xs:string" minOccurs="0" />
              <xs:element name="PurgeInStocker" type="xs:string" minOccurs="0" />
              <xs:element name="Coefficient" type="xs:string" minOccurs="0" />
              <xs:element name="OperShortDescription" type="xs:string" minOccurs="0" />
              <xs:element name="Associated_x0020_Entities_x0020_with_x0020_Purge_x0020_Enabled" type="xs:string" minOccurs="0" />
              <xs:element name="Associated_x0020_Entities_x0020_with_x0020_Purge_x0020_Disabled_x0020_or_x0020_Status_x0020_Unknown" type="xs:string" minOccurs="0" />
              <xs:element name="Comment" type="xs:string" minOccurs="0" />
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:complexType>
  </xs:element>
</xs:schema>
</TableSchema>
  <TableData />
  <LastRunAbsoluteDateFilter />
  <PivotGroupingSettings PivotColumn="">
    <SortyByColumn>Count</SortyByColumn>
  </PivotGroupingSettings>
  <QuerySQL><![CDATA[
--[FileName:"D:\Dashboard\Jobs\PCAM\6-hr\Purge_Metrics_XEUS.lasx"]------
----------<VARIABLES>------------
var MAO_USERID = "@{USERID_NON_MFG}"
var FILEFILTER = "@{DASHBOARD_PERSIST_DATA}\PCAM\Output\1_Purge_CRM_Configuration_Data_XEUS.csv"
var PURGE_EXCLUDE_PROCESS = "@{PURGE_EXCLUDE_PROCESS}"
---Begin Main Query---
Using CSV with
SELECT
	*
FROM
	${FILEFILTER}

]]></QuerySQL>
</QueryConfig>