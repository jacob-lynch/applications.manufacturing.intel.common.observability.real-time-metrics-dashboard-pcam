<QueryConfig AutoExecuteQueryOnLoad="false">
  <ChangeLog>Changed by AMR\mfg_dmdavies on 3/10/2015 3:46:15 PM from RF3PAP216N3.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.8.40713.1943</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 11/4/2014 12:44:43 PM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.8.40923.2310</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 11/4/2014 12:43:21 PM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.8.40923.2310</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 11/4/2014 12:41:51 PM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.8.40923.2310</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 8/18/2014 1:10:19 PM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.8.40806.2215</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 8/18/2014 1:09:40 PM from RF3PTS216.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.8.40806.2215</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_penarvae on 7/19/2013 1:19:45 AM from RF3PAP216N3.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.7.30711.1341</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_penarvae on 7/19/2013 1:18:49 AM from RF3PAP216N3.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.7.30711.1341</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_penarvae on 7/11/2013 3:06:25 PM from RF3PAP216N1.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.7.30527.2151</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_penarvae on 7/11/2013 3:02:54 PM from RF3PAP216N1.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.7.30527.2151</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_penarvae on 7/11/2013 3:01:59 PM from RF3PAP216N1.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.7.30527.2151</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_penarvae on 5/16/2013 11:21:48 PM from RF3PAP216N3.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.6.30225.0930</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_penarvae on 5/16/2013 11:19:32 PM from RF3PAP216N3.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.6.30225.0930</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_penarvae on 5/16/2013 11:08:48 PM from RF3PAP216N3.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.6.30225.0930</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_penarvae on 5/16/2013 11:06:55 PM from RF3PAP216N3.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.6.30225.0930</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_penarvae on 5/16/2013 3:39:05 PM from RF3PAP216N3.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.6.30225.0930</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 5/13/2013 4:47:12 PM from RF3PTS215.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.7.30508.1732</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 5/13/2013 4:46:56 PM from RF3PTS215.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.7.30508.1732</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 5/13/2013 3:46:28 PM from RF3PTS215.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.7.30508.1732</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 5/13/2013 3:45:48 PM from RF3PTS215.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.7.30508.1732</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 5/13/2013 9:43:27 AM from RF3PTS215.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.7.30508.1732</ChangeLog>
  <ChangeLog>Changed by AMR\amodi on 2/3/2011 3:53:21 PM from AMODI-DEV1.LTDAUTO.INTEL.COM using LogAnalyzer2 v2.3.10203.1546</ChangeLog>
  <ChangeLog>Changed by AMR\amodi on 9/3/2009 10:36:46 PM from AMODI-DEV1.LTDAUTO.INTEL.COM</ChangeLog>
  <QueryAttributes>
    <RowThresholdForPivotGrid>1000000</RowThresholdForPivotGrid>
    <AlwaysReplaceDomainWithLocal>false</AlwaysReplaceDomainWithLocal>
  </QueryAttributes>
  <PostQuerySQL>select * from %{OUTPUT}</PostQuerySQL>
  <TableLayoutConfig>
    <BoundColumnList>Area,Requestor,Title,Requested,Needed,SameDayRequest,WeekendRequest,Rejected</BoundColumnList>
  </TableLayoutConfig>
  <TabOrder>C0,G0,G1,G2,G3,G4,G5</TabOrder>
  <MainPivotConfig>
    <ColumnX FieldName="Requestor" FieldType="String" SortMode="Default" SortOrder="Ascending" SummaryType="Count" SortBySummaryInfo="false" />
    <ColumnY FieldName="" FieldType="" SortMode="Default" SortOrder="Ascending" SummaryType="Count" SortBySummaryInfo="false" />
    <ColumnData FieldName="" FieldType="" SortMode="Default" SortOrder="Ascending" SummaryType="Count" SortBySummaryInfo="false" />
    <TopN>10</TopN>
    <CustomPalette />
    <TableData />
  </MainPivotConfig>
  <OutputDataGridConfig Name="By Area - This Year" IncludeInBody="false" IncludeInAttachment="true">
    <SQL>----------&lt;VARIABLES&gt;------------
var TIMEFILTER = "this year"
---[MAIN_CSV]---
BEGIN MAIN_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		Area,
		Requestor,
		Title,
		Requested,
		WeekendRequest,
		Rejected
	FROM
		%{OUTPUT}
	WHERE
		ApplyTimeRangeFilter(Requested, '${TIMEFILTER}')
		AND Area is not NULL
		and Area not like ', Select From List'
END MAIN_CSV
---[TOTAL_CSV]---
BEGIN TOTAL_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		Area,
		Count(Title) as TotalRequests
	FROM
		%{MAIN_CSV}
	GROUP BY
		Area
	ORDER BY
		Area
END TOTAL_CSV
---[WEEKEND_CSV]---
BEGIN WEEKEND_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		Area,
		WeekendRequest,
		MUL(PROPCOUNT(*) on (AREA), 100.0) as [% Weekend]
	FROM
		%{MAIN_CSV}
	GROUP BY
		Area, WeekendRequest
	ORDER BY
		Area, WeekendRequest
END WEEKEND_CSV
---[REJECT_CSV]---
BEGIN REJECT_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		Area,
		Rejected,
		MUL(PROPCOUNT(*) on (AREA), 100.0) as [% Rejected]
	FROM
		%{MAIN_CSV}
	GROUP BY
		Area, Rejected
	ORDER BY
		Area, Rejected
END REJECT_CSV
---[JOIN_CSV]---
BEGIN JOIN_CSV
	UseMethod Join with -- **Do an outer join for two tables based on a matching column**
		InputFile1 = "%{TOTAL_CSV}" -- Input CSV File #1 containing table data [String]
		InputFile2 = "%{WEEKEND_CSV}" -- Input CSV File #2 containing table data [String]
		InputFile3 = "%{REJECT_CSV}" -- Input CSV File #3 containing table data (optional) [String]
		JoinColumn = "Area" -- Column name(s) on which to join the two tables (more than one column can be supplied by using comma as a separator) [String]
		IgnoreDuplicate = true -- Flag to ignore duplicate items in the JoinColumn [Boolean]
		IgnoreCase = false -- Flag to ignore case in the JoinColumn [Boolean]
		OnlyShowNonMatchingRows = false -- Flag to only show non-matching orphan rows [Boolean]
		IncludeNonMatchingRows = false -- Flag to also include non-matching orphan rows (but with blank entries) [Boolean]
		MustIncludeOutputColumns = "" -- Name of columns (comma-separated) that must be included in output even if the join does not materialize [String]
END JOIN_CSV
---Begin Main Query---
Using CSV with
SELECT
	Area,
	TotalRequests,
	[% of Weekend],
	[% of Rejected]
USING
	STRCAT(TO_STRING(SUB(100, to_int([% Weekend]))), '%') as [% of Weekend],
	STRCAT(TO_STRING(SUB(100, to_int([% Rejected]))), '%') as [% of Rejected]
FROM
	%{JOIN_CSV}
ORDER BY
	TotalRequests desc
</SQL>
    <TableLayoutConfig>
      <BoundColumnList>Area,TotalRequests,% of Same Day,% of Weekend,% of Rejected</BoundColumnList>
    </TableLayoutConfig>
    <CellHighlightingRules Enable="true" ColumnName="% of Weekend" FilterRegex="^0%" CellColorString="NamedColor:LimeGreen" />
    <CellHighlightingRules Enable="true" ColumnName="% of Rejected" FilterRegex="^0%" CellColorString="NamedColor:LimeGreen" />
    <TableSchema><xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Results" msdata:UseCurrentLocale="true">
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="Results">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="Area" type="xs:string" minOccurs="0" />
              <xs:element name="TotalRequests" type="xs:int" minOccurs="0" />
              <xs:element name="_x0025__x0020_of_x0020_Weekend" type="xs:string" minOccurs="0" />
              <xs:element name="_x0025__x0020_of_x0020_Rejected" type="xs:string" minOccurs="0" />
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:complexType>
  </xs:element>
</xs:schema>
</TableSchema>
    <TableData />
  </OutputDataGridConfig>
  <OutputDataGridConfig Name="By Area - Last Year" IncludeInBody="false" IncludeInAttachment="true">
    <SQL>----------&lt;VARIABLES&gt;------------
var TIMEFILTER = "Last 1 years (prev mode)"
---[MAIN_CSV]---
BEGIN MAIN_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		Area,
		Requestor,
		Title,
		Requested,
		WeekendRequest,
		Rejected
	FROM
		%{OUTPUT}
	WHERE
		ApplyTimeRangeFilter(Requested, '${TIMEFILTER}')
		AND Area is not NULL
		and Area not like ', Select From List'
END MAIN_CSV
---[TOTAL_CSV]---
BEGIN TOTAL_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		Area,
		Count(Title) as TotalRequests
	FROM
		%{MAIN_CSV}
	GROUP BY
		Area
	ORDER BY
		Area
END TOTAL_CSV
---[WEEKEND_CSV]---
BEGIN WEEKEND_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		Area,
		WeekendRequest,
		MUL(PROPCOUNT(*) on (AREA), 100.0) as [% Weekend]
	FROM
		%{MAIN_CSV}
	GROUP BY
		Area, WeekendRequest
	ORDER BY
		Area, WeekendRequest
END WEEKEND_CSV
---[REJECT_CSV]---
BEGIN REJECT_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		Area,
		Rejected,
		MUL(PROPCOUNT(*) on (AREA), 100.0) as [% Rejected]
	FROM
		%{MAIN_CSV}
	GROUP BY
		Area, Rejected
	ORDER BY
		Area, Rejected
END REJECT_CSV
---[JOIN_CSV]---
BEGIN JOIN_CSV
	UseMethod Join with -- **Do an outer join for two tables based on a matching column**
		InputFile1 = "%{TOTAL_CSV}" -- Input CSV File #1 containing table data [String]
		InputFile2 = "%{WEEKEND_CSV}" -- Input CSV File #2 containing table data [String]
		InputFile3 = "%{REJECT_CSV}" -- Input CSV File #3 containing table data (optional) [String]
		JoinColumn = "Area" -- Column name(s) on which to join the two tables (more than one column can be supplied by using comma as a separator) [String]
		IgnoreDuplicate = true -- Flag to ignore duplicate items in the JoinColumn [Boolean]
		IgnoreCase = false -- Flag to ignore case in the JoinColumn [Boolean]
		OnlyShowNonMatchingRows = false -- Flag to only show non-matching orphan rows [Boolean]
		IncludeNonMatchingRows = false -- Flag to also include non-matching orphan rows (but with blank entries) [Boolean]
		MustIncludeOutputColumns = "" -- Name of columns (comma-separated) that must be included in output even if the join does not materialize [String]
END JOIN_CSV
---Begin Main Query---
Using CSV with
SELECT
	Area,
	TotalRequests,
	[% of Weekend],
	[% of Rejected]
USING
	STRCAT(TO_STRING(SUB(100, to_int([% Weekend]))), '%') as [% of Weekend],
	STRCAT(TO_STRING(SUB(100, to_int([% Rejected]))), '%') as [% of Rejected]
FROM
	%{JOIN_CSV}
ORDER BY
	TotalRequests desc
</SQL>
    <TableLayoutConfig>
      <BoundColumnList>Area,TotalRequests,% of Same Day,% of Weekend,% of Rejected</BoundColumnList>
    </TableLayoutConfig>
    <CellHighlightingRules Enable="true" ColumnName="% of Same Day" FilterRegex="^0%" CellColorString="NamedColor:LimeGreen" />
    <CellHighlightingRules Enable="true" ColumnName="% of Weekend" FilterRegex="^0%" CellColorString="NamedColor:LimeGreen" />
    <CellHighlightingRules Enable="true" ColumnName="% of Rejected" FilterRegex="^0%" CellColorString="NamedColor:LimeGreen" />
    <TableSchema><xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Results" msdata:UseCurrentLocale="true">
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="Results">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="Area" type="xs:string" minOccurs="0" />
              <xs:element name="TotalRequests" type="xs:int" minOccurs="0" />
              <xs:element name="_x0025__x0020_of_x0020_Weekend" type="xs:string" minOccurs="0" />
              <xs:element name="_x0025__x0020_of_x0020_Rejected" type="xs:string" minOccurs="0" />
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:complexType>
  </xs:element>
</xs:schema>
</TableSchema>
    <TableData />
  </OutputDataGridConfig>
  <OutputDataGridConfig Name="By Customer - This Year" IncludeInBody="false" IncludeInAttachment="true">
    <SQL>----------&lt;VARIABLES&gt;------------
var TIMEFILTER = "this year"
---[MAIN_CSV]---
BEGIN MAIN_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		Area,
		Requestor,
		Title,
		Requested,
		WeekendRequest,
		Rejected
	FROM
		%{OUTPUT}
	WHERE
		ApplyTimeRangeFilter(Requested, '${TIMEFILTER}')
		AND Requestor is not NULL
END MAIN_CSV
---[TOTAL_CSV]---
BEGIN TOTAL_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		Requestor,
		Count(Title) as TotalRequests
	FROM
		%{MAIN_CSV}
	GROUP BY
		Requestor
	ORDER BY
		Requestor
END TOTAL_CSV
---[WEEKEND_CSV]---
BEGIN WEEKEND_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		Requestor,
		WeekendRequest,
		MUL(PROPCOUNT(*) on (Requestor), 100.0) as [% Weekend]
	FROM
		%{MAIN_CSV}
	GROUP BY
		Requestor, WeekendRequest
	ORDER BY
		Requestor, WeekendRequest
END WEEKEND_CSV
---[REJECT_CSV]---
BEGIN REJECT_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		Requestor,
		Rejected,
		MUL(PROPCOUNT(*) on (Requestor), 100.0) as [% Rejected]
	FROM
		%{MAIN_CSV}
	GROUP BY
		Requestor, Rejected
	ORDER BY
		Requestor, Rejected
END REJECT_CSV
---[JOIN_CSV]---
BEGIN JOIN_CSV
	UseMethod Join with -- **Do an outer join for two tables based on a matching column**
		InputFile1 = "%{TOTAL_CSV}" -- Input CSV File #1 containing table data [String]
		InputFile2 = "%{WEEKEND_CSV}" -- Input CSV File #2 containing table data [String]
		InputFile3 = "%{REJECT_CSV}" -- Input CSV File #3 containing table data (optional) [String]
		JoinColumn = "Requestor" -- Column name(s) on which to join the two tables (more than one column can be supplied by using comma as a separator) [String]
		IgnoreDuplicate = true -- Flag to ignore duplicate items in the JoinColumn [Boolean]
		IgnoreCase = false -- Flag to ignore case in the JoinColumn [Boolean]
		OnlyShowNonMatchingRows = false -- Flag to only show non-matching orphan rows [Boolean]
		IncludeNonMatchingRows = false -- Flag to also include non-matching orphan rows (but with blank entries) [Boolean]
		MustIncludeOutputColumns = "" -- Name of columns (comma-separated) that must be included in output even if the join does not materialize [String]
END JOIN_CSV
---Begin Main Query---
Using CSV with
SELECT
	Requestor,
	TotalRequests,
	[% of Weekend],
	[% of Rejected]
USING
	STRCAT(TO_STRING(SUB(100, to_int([% Weekend]))), '%') as [% of Weekend],
	STRCAT(TO_STRING(SUB(100, to_int([% Rejected]))), '%') as [% of Rejected]
FROM
	%{JOIN_CSV}
ORDER BY
	TotalRequests desc
</SQL>
    <TableLayoutConfig>
      <BoundColumnList>Requestor,TotalRequests,% of Same Day,% of Weekend,% of Rejected</BoundColumnList>
    </TableLayoutConfig>
    <CellHighlightingRules Enable="true" ColumnName="% of Same Day" FilterRegex="^0%" CellColorString="NamedColor:LimeGreen" />
    <CellHighlightingRules Enable="true" ColumnName="% of Weekend" FilterRegex="^0%" CellColorString="NamedColor:LimeGreen" />
    <CellHighlightingRules Enable="true" ColumnName="% of Rejected" FilterRegex="^0%" CellColorString="NamedColor:LimeGreen" />
    <TableSchema><xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Results" msdata:UseCurrentLocale="true">
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="Results">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="Requestor" type="xs:string" minOccurs="0" />
              <xs:element name="TotalRequests" type="xs:int" minOccurs="0" />
              <xs:element name="_x0025__x0020_of_x0020_Weekend" type="xs:string" minOccurs="0" />
              <xs:element name="_x0025__x0020_of_x0020_Rejected" type="xs:string" minOccurs="0" />
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:complexType>
  </xs:element>
</xs:schema>
</TableSchema>
    <TableData />
  </OutputDataGridConfig>
  <OutputDataGridConfig Name="By Customer - Last Year" IncludeInBody="false" IncludeInAttachment="true">
    <SQL>----------&lt;VARIABLES&gt;------------
var TIMEFILTER = "Last 1 years (prev mode)"
---[MAIN_CSV]---
BEGIN MAIN_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		Area,
		Requestor,
		Title,
		Requested,
		WeekendRequest,
		Rejected
	FROM
		%{OUTPUT}
	WHERE
		ApplyTimeRangeFilter(Requested, '${TIMEFILTER}')
		AND Requestor is not NULL
END MAIN_CSV
---[TOTAL_CSV]---
BEGIN TOTAL_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		Requestor,
		Count(Title) as TotalRequests
	FROM
		%{MAIN_CSV}
	GROUP BY
		Requestor
	ORDER BY
		Requestor
END TOTAL_CSV
---[WEEKEND_CSV]---
BEGIN WEEKEND_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		Requestor,
		WeekendRequest,
		MUL(PROPCOUNT(*) on (Requestor), 100.0) as [% Weekend]
	FROM
		%{MAIN_CSV}
	GROUP BY
		Requestor, WeekendRequest
	ORDER BY
		Requestor, WeekendRequest
END WEEKEND_CSV
---[REJECT_CSV]---
BEGIN REJECT_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		Requestor,
		Rejected,
		MUL(PROPCOUNT(*) on (Requestor), 100.0) as [% Rejected]
	FROM
		%{MAIN_CSV}
	GROUP BY
		Requestor, Rejected
	ORDER BY
		Requestor, Rejected
END REJECT_CSV
---[JOIN_CSV]---
BEGIN JOIN_CSV
	UseMethod Join with -- **Do an outer join for two tables based on a matching column**
		InputFile1 = "%{TOTAL_CSV}" -- Input CSV File #1 containing table data [String]
		InputFile2 = "%{WEEKEND_CSV}" -- Input CSV File #2 containing table data [String]
		InputFile3 = "%{REJECT_CSV}" -- Input CSV File #3 containing table data (optional) [String]
		JoinColumn = "Requestor" -- Column name(s) on which to join the two tables (more than one column can be supplied by using comma as a separator) [String]
		IgnoreDuplicate = true -- Flag to ignore duplicate items in the JoinColumn [Boolean]
		IgnoreCase = false -- Flag to ignore case in the JoinColumn [Boolean]
		OnlyShowNonMatchingRows = false -- Flag to only show non-matching orphan rows [Boolean]
		IncludeNonMatchingRows = false -- Flag to also include non-matching orphan rows (but with blank entries) [Boolean]
		MustIncludeOutputColumns = "" -- Name of columns (comma-separated) that must be included in output even if the join does not materialize [String]
END JOIN_CSV
---Begin Main Query---
Using CSV with
SELECT
	Requestor,
	TotalRequests,
	[% of Weekend],
	[% of Rejected]
USING
	STRCAT(TO_STRING(SUB(100, to_int([% Weekend]))), '%') as [% of Weekend],
	STRCAT(TO_STRING(SUB(100, to_int([% Rejected]))), '%') as [% of Rejected]
FROM
	%{JOIN_CSV}
ORDER BY
	TotalRequests desc
</SQL>
    <TableLayoutConfig>
      <BoundColumnList>Requestor,TotalRequests,% of Same Day,% of Weekend,% of Rejected</BoundColumnList>
    </TableLayoutConfig>
    <CellHighlightingRules Enable="true" ColumnName="% of Same Day" FilterRegex="^0%" CellColorString="NamedColor:LimeGreen" />
    <CellHighlightingRules Enable="true" ColumnName="% of Weekend" FilterRegex="^0%" CellColorString="NamedColor:LimeGreen" />
    <CellHighlightingRules Enable="true" ColumnName="% of Rejected" FilterRegex="^0%" CellColorString="NamedColor:LimeGreen" />
    <TableSchema><xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Results" msdata:UseCurrentLocale="true">
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="Results">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="Requestor" type="xs:string" minOccurs="0" />
              <xs:element name="TotalRequests" type="xs:int" minOccurs="0" />
              <xs:element name="_x0025__x0020_of_x0020_Weekend" type="xs:string" minOccurs="0" />
              <xs:element name="_x0025__x0020_of_x0020_Rejected" type="xs:string" minOccurs="0" />
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:complexType>
  </xs:element>
</xs:schema>
</TableSchema>
    <TableData />
  </OutputDataGridConfig>
  <OutputDataGridConfig Name="By GL - This Year" IncludeInBody="false" IncludeInAttachment="true">
    <SQL>----------&lt;VARIABLES&gt;------------
var TIMEFILTER = "this year"
---[MAIN_CSV]---
BEGIN MAIN_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		Area,
		RequestorGL,
		Title,
		Requested,
		WeekendRequest,
		Rejected
	FROM
		%{OUTPUT}
	WHERE
		ApplyTimeRangeFilter(Requested, '${TIMEFILTER}')
		AND Area is not NULL
		and Area not like ', Select From List'
END MAIN_CSV
---[TOTAL_CSV]---
BEGIN TOTAL_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		RequestorGL,
		Count(Title) as TotalRequests
	FROM
		%{MAIN_CSV}
	GROUP BY
		RequestorGL
	ORDER BY
		RequestorGL
END TOTAL_CSV
---[WEEKEND_CSV]---
BEGIN WEEKEND_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		RequestorGL,
		WeekendRequest,
		MUL(PROPCOUNT(*) on (RequestorGL), 100.0) as [% Weekend]
	FROM
		%{MAIN_CSV}
	GROUP BY
		RequestorGL, WeekendRequest
	ORDER BY
		RequestorGL, WeekendRequest
END WEEKEND_CSV
---[REJECT_CSV]---
BEGIN REJECT_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		RequestorGL,
		Rejected,
		MUL(PROPCOUNT(*) on (RequestorGL), 100.0) as [% Rejected]
	FROM
		%{MAIN_CSV}
	GROUP BY
		RequestorGL, Rejected
	ORDER BY
		RequestorGL, Rejected
END REJECT_CSV
---[JOIN_CSV]---
BEGIN JOIN_CSV
	UseMethod Join with -- **Do an outer join for two tables based on a matching column**
		InputFile1 = "%{TOTAL_CSV}" -- Input CSV File #1 containing table data [String]
		InputFile2 = "%{WEEKEND_CSV}" -- Input CSV File #2 containing table data [String]
		InputFile3 = "%{REJECT_CSV}" -- Input CSV File #3 containing table data (optional) [String]
		JoinColumn = "RequestorGL" -- Column name(s) on which to join the two tables (more than one column can be supplied by using comma as a separator) [String]
		IgnoreDuplicate = true -- Flag to ignore duplicate items in the JoinColumn [Boolean]
		IgnoreCase = false -- Flag to ignore case in the JoinColumn [Boolean]
		OnlyShowNonMatchingRows = false -- Flag to only show non-matching orphan rows [Boolean]
		IncludeNonMatchingRows = false -- Flag to also include non-matching orphan rows (but with blank entries) [Boolean]
		MustIncludeOutputColumns = "" -- Name of columns (comma-separated) that must be included in output even if the join does not materialize [String]
END JOIN_CSV
---Begin Main Query---
Using CSV with
SELECT
	RequestorGL,
	TotalRequests,
	[% of Weekend],
	[% of Rejected]
USING
	STRCAT(TO_STRING(SUB(100, to_int([% Weekend]))), '%') as [% of Weekend],
	STRCAT(TO_STRING(SUB(100, to_int([% Rejected]))), '%') as [% of Rejected]
FROM
	%{JOIN_CSV}
ORDER BY
	TotalRequests desc
</SQL>
    <TableLayoutConfig>
      <BoundColumnList>Area,TotalRequests,% of Same Day,% of Weekend,% of Rejected</BoundColumnList>
    </TableLayoutConfig>
    <CellHighlightingRules Enable="true" ColumnName="% of Same Day" FilterRegex="^0%" CellColorString="NamedColor:LimeGreen" />
    <CellHighlightingRules Enable="true" ColumnName="% of Weekend" FilterRegex="^0%" CellColorString="NamedColor:LimeGreen" />
    <CellHighlightingRules Enable="true" ColumnName="% of Rejected" FilterRegex="^0%" CellColorString="NamedColor:LimeGreen" />
    <TableSchema><xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Results" msdata:UseCurrentLocale="true">
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="Results">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="RequestorGL" type="xs:string" minOccurs="0" />
              <xs:element name="TotalRequests" type="xs:int" minOccurs="0" />
              <xs:element name="_x0025__x0020_of_x0020_Weekend" type="xs:string" minOccurs="0" />
              <xs:element name="_x0025__x0020_of_x0020_Rejected" type="xs:string" minOccurs="0" />
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:complexType>
  </xs:element>
</xs:schema>
</TableSchema>
    <TableData />
  </OutputDataGridConfig>
  <OutputDataGridConfig Name="By GL - Last Year" IncludeInBody="false" IncludeInAttachment="true">
    <SQL>----------&lt;VARIABLES&gt;------------
var TIMEFILTER = "Last 1 years (prev mode)"
---[MAIN_CSV]---
BEGIN MAIN_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		Area,
		RequestorGL,
		Title,
		Requested,
		WeekendRequest,
		Rejected
	FROM
		%{OUTPUT}
	WHERE
		ApplyTimeRangeFilter(Requested, '${TIMEFILTER}')
		AND Area is not NULL
		and Area not like ', Select From List'
END MAIN_CSV
---[TOTAL_CSV]---
BEGIN TOTAL_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		RequestorGL,
		Count(Title) as TotalRequests
	FROM
		%{MAIN_CSV}
	GROUP BY
		RequestorGL
	ORDER BY
		RequestorGL
END TOTAL_CSV
---[WEEKEND_CSV]---
BEGIN WEEKEND_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		RequestorGL,
		WeekendRequest,
		MUL(PROPCOUNT(*) on (RequestorGL), 100.0) as [% Weekend]
	FROM
		%{MAIN_CSV}
	GROUP BY
		RequestorGL, WeekendRequest
	ORDER BY
		RequestorGL, WeekendRequest
END WEEKEND_CSV
---[REJECT_CSV]---
BEGIN REJECT_CSV
	---Begin Main Query---
	Using CSV with
	SELECT
		RequestorGL,
		Rejected,
		MUL(PROPCOUNT(*) on (RequestorGL), 100.0) as [% Rejected]
	FROM
		%{MAIN_CSV}
	GROUP BY
		RequestorGL, Rejected
	ORDER BY
		RequestorGL, Rejected
END REJECT_CSV
---[JOIN_CSV]---
BEGIN JOIN_CSV
	UseMethod Join with -- **Do an outer join for two tables based on a matching column**
		InputFile1 = "%{TOTAL_CSV}" -- Input CSV File #1 containing table data [String]
		InputFile2 = "%{WEEKEND_CSV}" -- Input CSV File #2 containing table data [String]
		InputFile3 = "%{REJECT_CSV}" -- Input CSV File #3 containing table data (optional) [String]
		JoinColumn = "RequestorGL" -- Column name(s) on which to join the two tables (more than one column can be supplied by using comma as a separator) [String]
		IgnoreDuplicate = true -- Flag to ignore duplicate items in the JoinColumn [Boolean]
		IgnoreCase = false -- Flag to ignore case in the JoinColumn [Boolean]
		OnlyShowNonMatchingRows = false -- Flag to only show non-matching orphan rows [Boolean]
		IncludeNonMatchingRows = false -- Flag to also include non-matching orphan rows (but with blank entries) [Boolean]
		MustIncludeOutputColumns = "" -- Name of columns (comma-separated) that must be included in output even if the join does not materialize [String]
END JOIN_CSV
---Begin Main Query---
Using CSV with
SELECT
	RequestorGL,
	TotalRequests,
	[% of Weekend],
	[% of Rejected]
USING
	STRCAT(TO_STRING(SUB(100, to_int([% Weekend]))), '%') as [% of Weekend],
	STRCAT(TO_STRING(SUB(100, to_int([% Rejected]))), '%') as [% of Rejected]
FROM
	%{JOIN_CSV}
ORDER BY
	TotalRequests desc
</SQL>
    <TableLayoutConfig>
      <BoundColumnList>Area,TotalRequests,% of Same Day,% of Weekend,% of Rejected</BoundColumnList>
    </TableLayoutConfig>
    <CellHighlightingRules Enable="true" ColumnName="% of Same Day" FilterRegex="^0%" CellColorString="NamedColor:LimeGreen" />
    <CellHighlightingRules Enable="true" ColumnName="% of Weekend" FilterRegex="^0%" CellColorString="NamedColor:LimeGreen" />
    <CellHighlightingRules Enable="true" ColumnName="% of Rejected" FilterRegex="^0%" CellColorString="NamedColor:LimeGreen" />
    <TableSchema><xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Results" msdata:UseCurrentLocale="true">
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="Results">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="RequestorGL" type="xs:string" minOccurs="0" />
              <xs:element name="TotalRequests" type="xs:int" minOccurs="0" />
              <xs:element name="_x0025__x0020_of_x0020_Weekend" type="xs:string" minOccurs="0" />
              <xs:element name="_x0025__x0020_of_x0020_Rejected" type="xs:string" minOccurs="0" />
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:complexType>
  </xs:element>
</xs:schema>
</TableSchema>
    <TableData />
  </OutputDataGridConfig>
  <AutoPivotConfig OutputDateFormat="yyyy ww.w HH:mm" StatisticalFunctionsForColumn="Avg, 50, 90,96, Count" />
  <MailConfig>
    <PostProcessingSQL Enable="false" />
    <EmailCondition Enable="false" Operator="&gt;=" ThresholdRowCount="0">
      <SQLQuery />
      <RunScriptBeforeEmailing>false</RunScriptBeforeEmailing>
      <Script />
    </EmailCondition>
    <PostProcessingCondition Enable="false" Operator="&gt;" ThresholdRowCount="0">
      <SQLQuery />
      <RunScriptBeforeEmailing>false</RunScriptBeforeEmailing>
    </PostProcessingCondition>
    <CopyCondition Enable="false" Operator="&gt;" ThresholdRowCount="0">
      <SQLQuery />
      <RunScriptBeforeEmailing>false</RunScriptBeforeEmailing>
    </CopyCondition>
    <SMTPServer>smtp.intel.com</SMTPServer>
    <From>LogAnalyzer2@intel.com</From>
    <ReplyTo>@{DASHBOARD_OWNER_ALERT_DIST}</ReplyTo>
    <To />
    <Subject>[${DOMAIN}] BarnumSN Customer Profiles</Subject>
    <Body />
    <OnlyProcessIfOutputChangedFromPreviousRun>false</OnlyProcessIfOutputChangedFromPreviousRun>
    <MailAttachments FileNamingFormat="${SETTINGS}" Excel="false" LAS="false" LAD="false" Exceptions="false" StatusLogs="false" PivotChart="false" ZipAttachments="false" DoNotSendAttachmentsWithEmail="false" IncludeJobStatisticsHeader="false" IncludeQuerySettingsFileHeader="false" IncludeVariableDefinitionHeader="false" IncludeRowCountInSubject="false" />
    <IncludeSQLQueryInBody>false</IncludeSQLQueryInBody>
    <TableInBody Enable="false">
      <SQL />
    </TableInBody>
    <CopyOutputToDirectory>true</CopyOutputToDirectory>
    <OutputDirectory>@{DASHBOARD_WEB_SPOOL}\PCAM\Output</OutputDirectory>
    <IncludeAutoPivotSummary>false</IncludeAutoPivotSummary>
    <IncludeCustomPivotSummary>false</IncludeCustomPivotSummary>
    <IgnoreExceptions>false</IgnoreExceptions>
    <OnlyCopyOutputIfEmailConditionIsMet>false</OnlyCopyOutputIfEmailConditionIsMet>
  </MailConfig>
  <TableSchema><xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Results" msdata:UseCurrentLocale="true">
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="Results">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="Area" type="xs:string" minOccurs="0" />
              <xs:element name="Requestor" type="xs:string" minOccurs="0" />
              <xs:element name="VIP_x003F_" type="xs:string" minOccurs="0" />
              <xs:element name="isGL_x003F_" type="xs:string" minOccurs="0" />
              <xs:element name="RequestorGL" type="xs:string" minOccurs="0" />
              <xs:element name="Title" type="xs:string" minOccurs="0" />
              <xs:element name="Requested" type="xs:dateTime" minOccurs="0" />
              <xs:element name="WeekendRequest" type="xs:string" minOccurs="0" />
              <xs:element name="Rejected" type="xs:string" minOccurs="0" />
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:complexType>
  </xs:element>
</xs:schema>
</TableSchema>
  <TableData />
  <LastRunAbsoluteDateFilter />
  <PivotGroupingSettings PivotColumn="">
    <SortyByColumn>Count</SortyByColumn>
  </PivotGroupingSettings>
  <QuerySQL><![CDATA[
--[FileName:"D:\Dashboard\Jobs\PCAM\15-min\BarnumSN_Customer_Profiles.lasx"]------
----------<VARIABLES>------------
var TIMEFILTER = "All"
var SQL_NODE = "@{BARNUMSN_SQL_NODE}"
var CATALOG = "@{BARNUMSN_CATALOG}"
var TABLE = "@{BARNUMSN_TABLE}"
var BLINK = "@{BARNUMSN_LINK}"
---[BARNUM_CSV]---
BEGIN BARNUM_CSV
	---Begin Main Query---
	Using SQLDB with
		HostName = "${SQL_NODE}"
		Database = "${CATALOG}"
		UserID = "SN_Reports"
		Password = "SN_Reports"
	SELECT
	  *
	FROM
	  ${TABLE}
	ORDER  BY
	  created_on DESC 
END BARNUM_CSV
---Begin Main Query---
Using CSV with
SELECT
	u_functional_area as Area,
	requestor as Requestor,
	vip as [VIP?],
	is_manager as [isGL?],
	requestor_manager as RequestorGL,
	short_description as Title,
	to_string(created_on, 'MM-dd-yyyy') as Requested,
	WeekendRequest,
	Rejected
USING
	Case index_of(to_string(created_on, 'dddd'), 'S') when null then null else 'Yes' end as WeekendRequest,
	Case incident_state when 'rejected' then 'Yes' else null end as Rejected
FROM
	%{BARNUM_CSV}

]]></QuerySQL>
</QueryConfig>