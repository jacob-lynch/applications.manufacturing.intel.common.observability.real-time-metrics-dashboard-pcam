<QueryConfig AutoExecuteQueryOnLoad="false" PreventSQLBeautification="false">
  <ChangeLog>Changed by AMR\mfg_nmcdanie on 6/8/2023 11:33:17 AM from RF3PVAP616N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.30523.2335</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_mjschlec on 5/22/2023 8:40:58 AM from RF3PVAP616N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.30505.1841</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_kjdejong on 3/9/2023 3:17:12 PM from RF3PVAP616N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.30105.0021</ChangeLog>
  <ChangeLog>Changed by AMR\rf3dash on 7/15/2021 2:23:39 PM from RF3PVAP616N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.10330.1516</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 1/5/2021 8:56:46 AM from RF3PVAP616N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.00628.2048</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 11/12/2020 9:33:10 AM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.00628.2048</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 11/12/2020 9:11:54 AM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.00628.2048</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_mkotovsk on 11/6/2020 11:15:37 PM from RF3PRD415N2.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.00628.2048</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_mkotovsk on 11/6/2020 11:11:40 PM from RF3PRD415N2.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.00628.2048</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_mkotovsk on 11/6/2020 10:52:08 PM from RF3PRD415N2.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.00628.2048</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_mkotovsk on 11/6/2020 5:40:06 AM from RF3PRD415N2.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.00628.2048</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 9/30/2020 8:38:10 AM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.00628.2048</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 9/14/2020 2:57:13 PM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.00628.2048</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 3/11/2019 12:48:29 PM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.70713.2318</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 3/11/2019 12:47:53 PM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.70713.2318</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 3/11/2019 12:46:44 PM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.70713.2318</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 3/11/2019 12:44:44 PM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.70713.2318</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 3/11/2019 12:42:57 PM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.70713.2318</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 3/11/2019 12:40:51 PM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.70713.2318</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 3/11/2019 12:39:20 PM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.70713.2318</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 3/11/2019 12:39:16 PM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.70713.2318</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 3/11/2019 12:38:37 PM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.70713.2318</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 3/11/2019 12:38:34 PM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.70713.2318</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 3/11/2019 12:37:28 PM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.70713.2318</ChangeLog>
  <ChangeLog>Changed by AMR\mfg_dmdavies on 3/11/2019 12:35:46 PM from RF3PVAP416N19.RF3PROD.MFG.INTEL.COM using LogAnalyzer2 v2.9.70713.2318</ChangeLog>
  <QueryAttributes>
    <SuppressAllExceptions>true</SuppressAllExceptions>
    <RowThresholdForPivotGrid>1000000</RowThresholdForPivotGrid>
  </QueryAttributes>
  <PostQuerySQL>select * from %{OUTPUT}</PostQuerySQL>
  <TableLayoutConfig>
    <BoundColumnList>NodeName,Type,SecPort,NSLookup,CFG,DNS</BoundColumnList>
  </TableLayoutConfig>
  <TabOrder>C0</TabOrder>
  <MainPivotConfig>
    <ColumnX FieldName="" FieldType="" SortMode="Default" SortOrder="Ascending" SummaryType="Count" SortBySummaryInfo="false" />
    <ColumnY FieldName="" FieldType="" SortMode="Default" SortOrder="Ascending" SummaryType="Count" SortBySummaryInfo="false" />
    <ColumnData FieldName="" FieldType="" SortMode="Default" SortOrder="Ascending" SummaryType="Count" SortBySummaryInfo="false" />
    <CustomPalette />
    <TableData />
  </MainPivotConfig>
  <AutoPivotConfig OutputDateFormat="yyyy ww.w HH:mm" StatisticalFunctionsForColumn="Avg, 50, 90,96, Count" />
  <MailConfig>
    <PostProcessingSQL Enable="true">
      <SQL>UseMethod SendPage with -- **Send notification to any user or group (Using Factory Communication)**
	Users = "${PAGING_LIST}" -- List of recipients to receive notification (comma-separated) [e.g., amodi,FC_Support] [String]
	Message = "SC HSMS IP Address Audit (see email)" -- Message content to be notified (500 characters or less) [String]
	ColumnsToIncludeValuesFor = "NodeName,Audit Result" -- List of columns to include values from (comma-separated) [String]
	Shift = "All" -- Shift for which to enable the notifications ("All" for all shifts, "1" for Shift 1, etc.) [String]
	TimeRangeForLimitingPages = "All" -- Time range in which to not send more than 1 notifcation in (e.g., Last 30 min) [String]
	MaximumMessageLength = 140 -- Maximum message length in characters (supported by notification client) [Int32]
	TableIndex = 1 -- Table to use to generate "ColumnsToIncludeValuesFor" (1 for main, 2 for Grid 2, etc. [Int32]
</SQL>
    </PostProcessingSQL>
    <EmailCondition Enable="true" Operator="&gt;" ThresholdRowCount="0">
      <SQLQuery />
      <RunScriptBeforeEmailing>false</RunScriptBeforeEmailing>
      <Script />
    </EmailCondition>
    <PostProcessingCondition Enable="true" Operator="&gt;" ThresholdRowCount="0">
      <SQLQuery />
      <RunScriptBeforeEmailing>false</RunScriptBeforeEmailing>
    </PostProcessingCondition>
    <CopyCondition Enable="false" Operator="&gt;" ThresholdRowCount="">
      <SQLQuery />
      <RunScriptBeforeEmailing>false</RunScriptBeforeEmailing>
    </CopyCondition>
    <SMTPServer>smtpauth.intel.com:587</SMTPServer>
    <From>LogAnalyzer2@intel.com</From>
    <ReplyTo>@{DASHBOARD_OWNER_ALERT_DIST}</ReplyTo>
    <To>@{PCAM_MONITOR_EMAIL}</To>
    <Subject>SC HSMS IP Address Audit</Subject>
    <Body>&lt;b&gt;&lt;font color="red"&gt;Action Required - HSMS file is configured incorrectly.  
&lt;/font&gt;&lt;/b&gt;
&lt;br&gt;
&lt;br&gt;
The IP address configured in the HSMS file for the winclients listed below do not match the DNS lookup for the associated tool. Please validate appropriate IP address and update accordingly.
&lt;br&gt;
&lt;br&gt;
&lt;b&gt;Additional details can be found &lt;a href=" http://autowiki.intel.com/index.php?title=AIT_Monitor_pages_and_response#SC_HSMS_IP_Address_Audit"&gt;here&lt;/a&gt;.&lt;/b&gt;
&lt;br&gt;
</Body>
    <MailAttachments FileNamingFormat="${SETTINGS}_yyyyMMdd_HHmm" Excel="false" CSV="false" LAS="false" LAD="false" Exceptions="false" StatusLogs="false" PivotChart="false" ZipAttachments="false" DoNotSendAttachmentsWithEmail="false" IncludeJobStatisticsHeader="false" IncludeQuerySettingsFileHeader="false" IncludeOutputDirectoryPath="false" IncludeVariableDefinitionHeader="false" IncludeRowCountInSubject="false" />
    <IncludeSQLQueryInBody>false</IncludeSQLQueryInBody>
    <TableInBody Enable="true">
      <SQL />
    </TableInBody>
    <CopyOutputToDirectory>false</CopyOutputToDirectory>
    <OutputDirectory />
    <IncludeAutoPivotSummary>false</IncludeAutoPivotSummary>
    <IgnoreExceptions>false</IgnoreExceptions>
    <SuppressMail>false</SuppressMail>
    <MailHighImportance>false</MailHighImportance>
    <OnlyCopyOutputIfEmailConditionIsMet>false</OnlyCopyOutputIfEmailConditionIsMet>
  </MailConfig>
  <TableSchema><xs:schema id="NewDataSet" xmlns="" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
  <xs:element name="NewDataSet" msdata:IsDataSet="true" msdata:MainDataTable="Results" msdata:UseCurrentLocale="true">
    <xs:complexType>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="Results">
          <xs:complexType>
            <xs:sequence>
              <xs:element name="NodeName" type="xs:string" minOccurs="0" />
              <xs:element name="Audit_x0020_Result" type="xs:string" minOccurs="0" />
              <xs:element name="SC_x0020_Type" type="xs:string" minOccurs="0" />
              <xs:element name="HSMS_x0020_Configuration_x0020_Path" type="xs:string" minOccurs="0" />
              <xs:element name="HSMS_x0020_Configuration" type="xs:string" minOccurs="0" />
              <xs:element name="DNS_x0020_Lookup" type="xs:string" minOccurs="0" />
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:complexType>
  </xs:element>
</xs:schema>
</TableSchema>
  <TableData />
  <LastRunAbsoluteDateFilter />
  <CustomQueryMethodScripts>//css_searchdir C:\Users\mfg_mkotovsk\Desktop; /* Added automatically by LA2 (please do not modify) */
//css_ref System.Xml; /* Added automatically by LA2 (please do not modify) */
//css_searchdir C:\Users\mfg_mkotovsk\Desktop; /* Added automatically by LA2 (please do not modify) */
//css_ref System.Xml; /* Added automatically by LA2 (please do not modify) */
using System;
using System.ComponentModel;
using System.Collections.Generic;
using System.Data;
using System.IO;
using System.Net;
using System.Text.RegularExpressions;
using Intel.LogAnalyzer.Common;
using Intel.LogAnalyzer.Utility;

namespace Intel.LogAnalyzer.CustomQueryMethods_ToolNSLookup
{
    public class ToolNSLookupQueryMethod : CustomQueryMethodBase
    {
        /// &lt;summary&gt;
        /// Test harness
        /// &lt;/summary&gt;
        [STAThread]
        private static void Main()
        {
            String cfg, dns;
            ToolNSLookupQueryMethod q = new ToolNSLookupQueryMethod();

            DataTable xeus = UtilityMethods.ConvertCSVFileToDataTable(@"C:\Users\mfg_mkotovsk\Desktop\xeus_sample.csv", false);
            DataTable test = UtilityMethods.ConvertCSVFileToDataTable(@"C:\Users\mfg_mkotovsk\Desktop\HSMS_tester_mapping.csv", false);
            DataTable over = UtilityMethods.ConvertCSVFileToDataTable(@"C:\Users\mfg_mkotovsk\Desktop\HSMS_secport_override.csv", false);
            List&lt;String&gt; litho = ("TelNikonLink,LithiusAsmlLink,Nikon_LithoLink,ASML_LithoLink").Split(",");
            List&lt;String&gt; tool = ("DOR,TEN").Split(",");

            var x = q.DoLookupMatch("R2PCVD04", @"\\R2PCVD04U\C$\SC\SC.NET\MachineControllers\SC.NET_NVLS_C3_CVD_1.1.0.900_FW_1.2.1\config\HSMS_secsport.cfg", out cfg, out dns, xeus, test, over, litho, tool);
        }

        // Output type is QueryResult
        public override CustomQueryOutputType OutputType { get { return CustomQueryOutputType.QueryResult; } }

        public override string Description
        {
            get { return "Custom NSLookup for SC"; }
        }

        [Description("Input CSV File containing table data")]
        public string InputFile { get; set; }

        [Description("Input CSV File containing litho mapping")]
        public string XEUSLithoMap { get; set; }

        [Description("Input CSV File containing winclient/ip overrides")]
        public string SecportOverride { get; set; }

        [Description("Input CSV File containing tester mapping")]
        public string TesterMap { get; set; }
        
        [Description("Comma separated list of litho MachineControllers")]
        public string LithoApps { get; set; }
                
        [Description("Comma separated list of Tool Exclusions")]
        public string ToolExclude { get; set; }
        
        [Description("Column containing NodeName")]
        public string NodeColumnName { get; set; }

        [Description(@"File name to check for = \\ NODENAME FOLDERNAME FILENAME (without spaces) ex: cmd.exe")]
        public string FileColumnName { get; set; }
        
        [Description(@"IP range to filter on, uses regex. ex: '10' or '(10|72)'")]
        public string IPFilter { get; set; }        

        public override QueryResult GetQueryResult()
        {
            return new QueryResult(string.Empty, Compute());
        }

        private DataTable Compute()
        {
            DataTable table = UtilityMethods.ConvertCSVFileToDataTable(InputFile, false);
            DataTable xeus = UtilityMethods.ConvertCSVFileToDataTable(XEUSLithoMap, false);
            DataTable test = UtilityMethods.ConvertCSVFileToDataTable(TesterMap, false);
            DataTable over = UtilityMethods.ConvertCSVFileToDataTable(SecportOverride, false);
            List&lt;String&gt; litho = LithoApps.Split(",");
            List&lt;String&gt; tool_excludes = ToolExclude.Split(",");

            table.Columns.Add("NSLookup", typeof(String));
            table.Columns.Add("CFG");
            table.Columns.Add("DNS");
			
            String tool, dns, cfg;
            foreach (DataRow dr in table.Rows)
            {
                try
                {
                    tool = dr[NodeColumnName].ToString();
                    tool = tool.Substring(0, tool.Length - 1);
                    dr["NSLookup"] = DoLookupMatch(tool, dr[FileColumnName].ToString(), out cfg, out dns, xeus, test, over, litho, tool_excludes);
                    dr["CFG"] = cfg;
                    dr["DNS"] = dns;
                }
                catch (Exception e) { }
            }

            return table;
        }

        private String DoLookupMatch(String node, String file, out String cfg_vals, out String dns_vals, DataTable xeus, DataTable tester, DataTable overrides, List&lt;String&gt; litho, List&lt;String&gt; tool_excludes)
        {
            List&lt;String&gt; config = new List&lt;string&gt;(); // list of all the addresses we need to validate
            bool parse_flag = false;
            bool parse_exception_flag = false;
            bool dns_flag = false;
            cfg_vals = dns_vals = "";

            node = node.ToUpper();

            foreach(String tool in tool_excludes)
            {
                if (node.Contains(tool.ToUpper()))
                    return "WARNING Ignored excluded Tool";
            }
            if (file.Contains("Dummy"))
                return "WARNING Ignored Dummy config";


            // Lookup SecPort configuration
            DoSecPortLookup(file, ref parse_flag, ref parse_exception_flag, ref cfg_vals, ref config);

            // process manual overrides
            foreach (DataRow row in overrides.Rows)
            {
                if (row["winclient"].ToString().ToUpper() == (node.ToUpper() + "U") &amp;&amp; config.Contains(row["ip"].ToString()))
                { 
                    config.Remove(row["ip"].ToString());
                    dns_vals = "OVERRIDE " + row["ip"];
                    if (!parse_flag &amp;&amp; !parse_exception_flag &amp;&amp; config.Count == 0)
                        return "Match";
                }
            }

            // Process DNS entry
            dns_flag = DoDNSLookup(node, ref dns_vals, ref config);

            // Check tester information for Etest dual-MA tools
            foreach (DataRow row in tester.Rows)
            {
                if (node.ToUpper().Contains(row["tool"].ToString().ToUpper()))
                    dns_flag = dns_flag &amp; DoDNSLookup(node.Replace(row["tool"].ToString().ToUpper(), row["tester"].ToString().ToUpper()), ref dns_vals,ref config);
            }

            // Check for Litho exceptions
            foreach (String l in litho)
            {
                // If this is a litho tool, see if we can map it in XEUS
                if (!file.Contains(l)) continue;
                foreach (DataRow row in xeus.Rows)
                {
                    if (node.ToUpper().Contains(row["Entity"].ToString().ToUpper()))
                    {
                        List&lt;String&gt; map = row["Mapping"].ToString().ToUpper().Replace(",",";").Replace(" ","").Split(";");
                        foreach (String tool in map)
                        {
                            dns_flag = dns_flag &amp; DoDNSLookup(node.Replace(row["Entity"].ToString().ToUpper(),tool), ref dns_vals, ref config);
                        }
                    }
                }
            }

            if (!parse_flag &amp;&amp; !dns_flag &amp;&amp; config.Count == 0)
                return "Match";
            if (!File.Exists(file))
                return "WARNING secport file not found";
            if (parse_flag &amp;&amp; parse_exception_flag)
                return "WARNING TOOLIPADDRESS variable found";
            if (parse_flag)
                return "ERROR Parsing secport file";
            if (dns_flag)
                return "ERROR resolving DNS for node";
            return "ERROR Mismatch DNS &amp; Config";
        }

        // Parses file to scrape ip addresses and leave them in config
        private void DoSecPortLookup(String file, ref bool parse_flag, ref bool parse_exception_flag, ref String cfg_vals, ref List&lt;String&gt; config)
        {
            StreamReader reader = null;

            if (!File.Exists(file))
                parse_flag = true;
            else
            {
                try
                {
                    String raw, address;
                    reader = new StreamReader(file);
                    // For each line in the file:
                    while ((raw = reader.ReadLine()) != null)
                    {
                        // Trim out any trailing comments
                        if (raw.Contains(@"//*"))
                            raw = raw.Substring(0, raw.IndexOf(@"//*"));
                        // An odd configuration exception
                        if (raw.Contains(@"${TOOLIPADDRESS}"))
                            parse_exception_flag = true;
                            
                        // If it contains a regex pattern, such as: 10 or (172|10)[.]0[.]
                        if (Regex.IsMatch(raw.Trim(), "PASSIVE ENTITY IPADDRESS " + IPFilter, RegexOptions.IgnoreCase))
                        {
                            // Trim down to the 10. address and regex for an IP address like block
                            address = raw.Substring(raw.LastIndexOf("IPADDRESS") + 10).Trim();
                            Match match = Regex.Match(address, @"(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})");
                            if (match.Success)
                                address = match.Captures[0].ToString();
                            if (!config.Contains(address))
                            {
                                // If the address is valid and not already in our list, add it
                                config.Add(address);
                                cfg_vals += (cfg_vals.Length == 0 ? "" : ";") + address;
                            }
                        }
                    }
                    if (config.Count == 0)
                        parse_flag = true;
                    reader.Close();
                }
                catch (Exception e)
                {
                    try
                    {
                        if (reader != null) reader.Close();
                    }
                    catch (Exception e2) { }
                    parse_flag = true;
                }
            }
        }

        // Does DNS lookup on node and removes config entries for found IP addresses from config
        // returns true if it cannot do any DNS lookup
        // returns false if DNS is addressable
        private bool DoDNSLookup(String node, ref String dns_vals, ref List&lt;String&gt; config)
        {
            try
            {
                bool unresolved = false;
                IPHostEntry resolved;
                try
                {
                    // Try to resolve without H, for each IP match in config, remove from config
                    resolved = Dns.GetHostEntry(node);
                    foreach (IPAddress ip in resolved.AddressList)
                    {
                        dns_vals += (dns_vals.Length == 0 ? "" : ";") + ip.ToString();
                        if (config.Contains(ip.ToString()))
                            config.Remove(ip.ToString());
                    }
                }
                catch (Exception e)
                {
                    // This should be expected most of the time, this is to catch some odd mappings
                    if (e.Message != "No such host is known")
                        throw e;
                    unresolved = true;
                }
                try
                {
                    // Try to resolve with H, for each IP match in config, remove from config
                    resolved = Dns.GetHostEntry(node + "H");
                    foreach (IPAddress ip in resolved.AddressList)
                    {
                        dns_vals += (dns_vals.Length == 0 ? "" : ";") + ip.ToString();
                        if (config.Contains(ip.ToString()))
                            config.Remove(ip.ToString());
                    }
                }
                catch (Exception e)
                {
                    if (unresolved || e.Message != "No such host is known")
                        throw e;
                }
            }
            catch (Exception e)
            {
                return true;
            }
            return false;
        }
    }
}

</CustomQueryMethodScripts>
  <PivotGroupingSettings PivotColumn="">
    <SortyByColumn>Count</SortyByColumn>
  </PivotGroupingSettings>
  <QuerySQL><![CDATA[
--[FileName:"D:\Dashboard\Jobs\PCAM\Monitor-12hr\HSMS Audit.lasx"]------
----------<VARIABLES>------------
var NODEFILTER = "@{WINCLIENT_NODE_LIST}"
var DOMAIN = "RF3PROD"
var PAGING_LIST = "@{PAGING_LIST}"
var IP_FILTER = "@{HSMS_IP_FILTER}"
var SC_SECPORT_INTERNAL = "\\%{NODELIST}\C$\SC\SC.NET\MachineControllers\{ACTIVEMCPATH}\config\HSMS_secsport.cfg"
var SC_REG_1_INTERNAL = "\\%{NODELIST}\HKLM\SOFTWARE\Intel\Orca\Install\Framework"
var SC_REG_2_INTERNAL = "\\%{NODELIST}\HKLM\SOFTWARE\Intel\FabAuto\SC.Net\Frameworks\"
var SC_REG_3_INTERNAL = "\\%{NODELIST}\HKLM\SOFTWARE\Intel\FabAuto\SC.Net\MachineControllers\"
var NTSC_SECPORT_INTERNAL = "\\%{NODELIST}\C$\{ACTIVEMCPATH}\config\HSMS_secsport.cfg"
var NTSC_REG_INTERNAL = "\\%{NODELIST}\HKLM\SOFTWARE\Intel\Orca\Install\MachineController"
var TIMEFILTER = "All"
var XEUSMAP_LITHO = "@{DASHBOARD_PERSIST_DATA}\PCAM\Output\1_MES Litho DualMA_XEUS.csv"
var HSMS_OVERRIDE = "@{DASHBOARD_PERSIST_DATA}\PCAM\Output\HSMS_secsport_override.csv"
var TESTER_MAPPING = "@{DASHBOARD_PERSIST_DATA}\PCAM\Output\HSMS_tester_mapping.csv"
var LITHO_APPS = "TelNikonLink,LithiusAsmlLink,Nikon_LithoLink,ASML_LithoLink,Ultratech_LithoLink,TSVNikon_LithoLink,TSVCanon_LithoLink"
var TOOL_EXCLUDE = "@{HSMS_EXCLUDE_LIST}"
var RESULTS_FILTER = "WARNING secport file not found,WARNING Ignored Dummy config,WARNING Ignored excluded Tool,WARNING TOOLIPADDRESS variable found,Match"
---[NODELIST]---
[ThreadQuery(1)] --** Invoke a separate thread for every 1 output row(s) of the {NODELIST} query
BEGIN NODELIST
	UseMethod GetNodeList with -- **Get the list of nodes matching specified domain and filter**
		Domain = "${DOMAIN}" -- Domain to search for nodes in (can be comma-separated-list) [String]
		NodeFilter = "${NODEFILTER}" -- Pattern to look for nodes (comma-separated-list) [String]
		OnlyIncludePingableNodes = true -- Only include nodes that can be pinged [Boolean]
		OnlyIncludeDNSComputerNameMatchedNodes = true -- DNS hostname from IP must match computername from registry [Boolean]
END NODELIST
---[ACTIVEFWPATH]---
BEGIN ACTIVEFWPATH
	---Begin Main Query---
	Using REG with
	SELECT
		Value
	FROM
		${SC_REG_1_INTERNAL}
	WHERE
		(ValueName = 'Active')
END ACTIVEFWPATH
---[REALFWPATH]---
BEGIN REALFWPATH
	---Begin Main Query---
	Using REG with
	SELECT
		Value
	FROM
		${SC_REG_2_INTERNAL}
	WHERE
		(ValueName = 'Active Package')
END REALFWPATH
---[SC_CSV]---
BEGIN SC_CSV
	---Begin Main Query---
	Using REG with
	SELECT
		ComputerName as NodeName,
		'SC.net' as Type,
		strcat('\\', Replace_str('${SC_SECPORT_INTERNAL}', '{ACTIVEMCPATH}', Value)) as SecPort
	FROM
		${SC_REG_3_INTERNAL}
	WHERE
		(ValueName = 'Active Package')
END SC_CSV
---[NTSC_CSV]---
BEGIN NTSC_CSV
	---Begin Main Query---
	Using REG with
	SELECT
		ComputerName AS NodeName,
		'NTSC' as Type,
		strcat('\\', Replace_str('${NTSC_SECPORT_INTERNAL}', '{ACTIVEMCPATH}', extract_token(Value, 1, ':\\'))) as SecPort
	FROM
		${NTSC_REG_INTERNAL}
	WHERE
		ValueName LIKE 'dir'
		AND
		(trim(to_lowercase(KeyName)) IN (
	SELECT
		trim(to_lowercase(Value))
	FROM
		${NTSC_REG_INTERNAL}
	WHERE
		(ValueName LIKE 'Active')
		))
END NTSC_CSV
---[MERGED_CSV]---
BEGIN MERGED_CSV
	UseMethod MergeTables with -- **Merge content of two tables by doing an outer join on the column schema (no join done here)**
		InputFile1 = "%{NTSC_CSV}" -- Input CSV File #1 containing table data [String]
		InputFile2 = "%{SC_CSV}" -- Input CSV File #2 containing table data [String]
		AutoDetectColumnTypes = false -- Auto-detect column types before merging [Boolean]
END MERGED_CSV
---[LOOKUPS_CSV]---
BEGIN LOOKUPS_CSV
	UseMethod ToolNSLookup with -- **Custom NSLookup for SC**
		InputFile = "%{MERGED_CSV}" -- Input CSV File containing table data [String]
		XEUSLithoMap = "${XEUSMAP_LITHO}" -- Input CSV File containing litho mapping [String]
		SecportOverride = "${HSMS_OVERRIDE}" -- Input CSV File containing winclient/ip overrides [String]
		TesterMap = "${TESTER_MAPPING}" -- Input CSV File containing tester mapping [String]
		LithoApps = "${LITHO_APPS}" -- Comma separated list of litho MachineControllers [String]
		ToolExclude = "${TOOL_EXCLUDE}" -- Comma separated list of Tool Exclusions [String]
		NodeColumnName = "NodeName" -- Column containing NodeName [String]
		FileColumnName = "SecPort" -- File name to check for = \\ NODENAME FOLDERNAME FILENAME (without spaces) ex: cmd.exe [String]
		IPFilter = "${IP_FILTER}" -- IP range to filter on, uses regex. ex: '10' or '(10|72)' [String]
END LOOKUPS_CSV
---Begin Main Query---
SELECT
	NodeName,
	NSLookup as [Audit Result],
	Type as [SC Type],
	SecPort as [HSMS Configuration Path],
	CFG as [HSMS Configuration],
	DNS as [DNS Lookup]
FROM
	%{LOOKUPS_CSV}
WHERE
	NOT IsInList(NSLookup,'${RESULTS_FILTER}')

]]></QuerySQL>
</QueryConfig>